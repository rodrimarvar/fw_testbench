<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: State Machines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_sm.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">State Machines</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_evt.html">Events</a></span><span class="next_button"><a class="el" href="srs-qp_edm.html">Event Delivery Mechanisms</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_sm-intro"></a>
Concepts &amp; Definitions</h1>
<p>Event-driven systems work by <a class="el" href="srs-qp_evt.html">responding to Events</a>. In general, the system's response to a given Event depends both on the nature of that Event (captured in its <a class="el" href="srs-qp_evt.html#srs-qp_evt-sig">Signal</a>) and on the <em>history of events</em> the system has received. In practice not all aspects of the full "history of past events" are relevant. The simplified history consisting only of aspects that are consequential for the system's response to <em>future events</em> is called the <b>Relevant History</b>.</p>
<h2><a class="anchor" id="srs-qp_sm-state"></a>
State</h2>
<p><b>State</b> is an <em>equivalence class</em> of past histories of a system, all of which are equivalent in the sense that the future behavior of the system given any of these past histories will be identical. Thus, the concept of "State" is the most efficient representation of the Relevant History of the system. It is the minimum information that captures only the relevant aspects for the future behavior and abstracts away all irrelevant aspects.</p>
<h2><a class="anchor" id="srs-qp_sm-tran"></a>
Transition</h2>
<p><b>Transition</b> is a change from one State to another during the lifetime of a system. In event-driven systems, a change from one state to another can be caused only by an event. The events that triggers a Transition is called <b>Triggering Event</b> or just <b>Trigger</b> of the Transition.</p>
<h2><a class="anchor" id="srs-qp_sm-def"></a>
State Machine</h2>
<p><b>State Machine</b> is the set of all States (<em>equivalence classes</em> of relevant histories), plus all the Transitions (rules for changing States). An important benefit of the State Machine formalism is the expressive graphical representation of State Machines in form of <b>state diagrams</b>.</p>
<dl class="section note"><dt>Note</dt><dd>This definition pertains to event-driven State Machines, which is the only kind supported in QP Framework. The definition does not cover "input-driven" state machines or other types of state machines.</dd></dl>
<h2><a class="anchor" id="srs-qp_sm-hsm"></a>
Hierarchical State Machine</h2>
<p><b>Hierarchical State Machine</b> (a.k.a. UML statechart) is an advanced formalism which extends the traditional state machines in several ways. The most important innovation of UML state machines over classical state machines is the introduction of <b>hierarchically nested states</b>. The value of state nesting lies in avoiding repetitions, which are inevitable in the traditional "flat" state machine formalism. The semantics of state nesting allow substates to define only the <em>differences</em> in behavior from the superstates, thus promoting sharing and reuse of behavior.</p>
<h2><a class="anchor" id="srs-qp_sm-impl"></a>
State Machine Implementation Strategy</h2>
<p>State Machines, and Hierarchical State Machines, in particular, can be implemented in many different ways. A specific way of implementing a state machine will be called here a <b>State Machine Implementation Strategy</b>, and it can be characterized by the following properties:</p>
<ul>
<li>efficiency in time (CPU cycles)</li>
<li>efficiency in data space (RAM footprint)</li>
<li>efficiency in code space (ROM footprint)</li>
<li>monolithic vs. partitioned with various levels of granularity</li>
<li>maintainability (with manual coding)</li>
<li>maintainability (via automatic code generation)</li>
<li><em>traceability</em> from design (e.g., state diagram) to code</li>
<li><em>traceability</em> from code back to design</li>
<li>other, quality attributes (non-functional requirements)</li>
</ul>
<p>No single state machine implementation strategy can be optimal for all circumstances, and therefore QP Framework shall support multiple and interchangeable strategies (see <a class="el" href="#SRS_QP_SM_20">SRS_QP_SM_20</a>).</p>
<h2><a class="anchor" id="srs-qp_sm-init"></a>
Initializing a State Machine</h2>
<p>Every state machine must be initialized before it can process any events. The initialization is accomplished by executing the top-most initial transition, which must be present in every well-formed state machine.</p>
<h2><a class="anchor" id="srs-qp_sm-dispatch"></a>
Dispatching Events to a State Machine</h2>
<p>The event processing inside a state machine is called <b>dispatching</b> an event to the state machine, and it requires interaction between the QP Framework and the QP Application, as illustrated in <a class="el" href="#srs-qp_fig-sm-dis">Figure RS-SM-DIS</a>. The process of <em>event dispatching</em> consists of multiple interactions between the <a class="el" href="#srs-qp_sm-proc">State Machine Processor</a> inside QP Framework and <a class="el" href="#srs-qp_sm-spec">State Machine Specification</a> inside QP Application. The framework chooses with elements of the "State Machine Specification" to call (e.g., states). The "Specification" then performs the actions and returns the <em>status</em> of processing (e.g., a transition has been taken) back to the "State Machine Processor". Based on this status, the "State Machine Processor" decides which element of the "Specification" to call next or that the processing is complete.</p>
<p><a class="anchor" id="srs-qp_fig-sm-dis"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_sm-dis.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-SM-DIS:Event Dispatching to a State Machine in QP Framework</em></center></div><h3><a class="anchor" id="srs-qp_sm-spec"></a>
State Machine Specification</h3>
<p>The "State Machine Specification" is provided inside the QP Application and is prepared according to the rules defined by the chosen <a class="el" href="#srs-qp_sm-impl">State Machine Implementation Strategy</a> in QP Framework. Typically an implementation strategy represents a state machine as several elements, such as states, transitions, etc.</p>
<p>The "State Machine Specification" can mean state machine code (when the state machine is coded manually) or a state machine model (when the state machine is specified in a modeling tool, like <a href="https://www.state-machine.com/products/qm" target="_blank" rel="noopener">"QM"&uarr;</a>). Either way, it is highly recommended to <em>think</em> of the state machine implementation as the <b>specification</b> of state machine elements, not merely code. This notion of "specifying" a state machine rather than coding it can be reinforced by selecting an expressive and fully <em>traceable</em> state machine implementation strategy, see <a class="el" href="#SRS_QP_SM_40">SRS_QP_SM_40</a>. The advantage of a traceable implementation is that each artifact at all levels of abstraction (design to code) unambiguously represents an element of a state machine.</p>
<h3><a class="anchor" id="srs-qp_sm-proc"></a>
State Machine Processor</h3>
<p>A state machine is executed in QP Framework by the "State Machine Processor" that decides which elements of the "State Machine Specification" to call. Once called, the chosen part of the "State Machine Specification" executes some actions and <em>returns</em> back to the "State Machine Processor" (QP Framework) with the status information as to what has happened. For example, the returned status might inform the "State Machine Processor" that a state transition needs to be taken, or that the event needs to be propagated to the superstate in the hierarchical state machine.</p>
<h3><a class="anchor" id="srs-qp_sm-rtc"></a>
Run To Completion (RTC) Processing</h3>
<p>The "State Machine Processor" is a <em>passive</em> software component that needs to be explicitly called from some context of execution (e.g., thread) to dispatch each event to the given state machine object. The most important restriction is that the dispatch operation must necessarily run to completion (<b>Run-to-Completion</b> processing) before another event can be dispatched to the same state machine object.</p>
<p>RTC event processing means, among others, that a state machine should <b>NOT</b> block or busy-poll for events (e.g., a semaphore-wait or busy-delay) because every such blocking or busy-polling represents waiting for an <em>event</em>, which will be delivered immediately after the call unblocks. The problem is that such a "backdoor" event is delivered before the original RTC step completes, thus violating the RTC semantics. Blocking inside a state machine also extends the RTC processing and makes the state machine unresponsive to new events.</p>
<h3><a class="anchor" id="srs-qp_sm-curr"></a>
Current State</h3>
<p>Between the discrete <a class="el" href="#srs-qp_sm-rtc">RTC steps</a>, the state machine remains in a stable state configuration, which is called the <b>current state</b>. The <em>current state</em> changes in real-time as the state machine executes RTC steps and transitions from one state to another. Because the state changes occur in run-time, every state machine must store its state in a <em>variable</em>, which is called <b>state variable</b>.</p>
<h3><a class="anchor" id="srs-qp_sm-evt"></a>
Current Event</h3>
<p>The event that has been dispatch to the state machine is called the <b>current event</b>. This current event must not change and must be accessible to the state machine over the entire <a class="el" href="#srs-qp_sm-rtc">RTC step</a>.</p>
<h1><a class="anchor" id="srs-qp_sm-req"></a>
Requirements</h1>
<p><a id="a25_SRS_5FQP_5FSM_5F00" name="a25_SRS_5FQP_5FSM_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_00"></a>
SRS_QP_SM_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_00</b>: <em>QP Framework shall provide support for hierarchical state machines both for Active Objects and for passive event-driven objects in the Application</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for hierarchical state machines (HSMs) means that QP Framework shall provide a set of rules for <a class="el" href="#srs-qp_sm-spec">State Machine Specifications</a> (rules for coding state machines in the QP Application) as well as the matching implementation of the <a class="el" href="#srs-qp_sm-proc">State Machine Processor</a> (inside the QP Framework) to handle events according to HSM semantics defined in requirements in this section. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">In QP Framework, state machines can be associated only with <em>objects</em>, which provide the execution context (e.g., the data and other resources accessed by the state machine, see also <a class="el" href="#SRS_QP_SM_22">SRS_QP_SM_22</a>). These objects can be both active and passive. Active Objects are specified in the dedicated <a class="el" href="srs-qp_ao.html">section of this requirement specification document</a>. Passive objects with a state machine can be useful as event-driven components ("Orthogonal Components") inside Active Objects or inside device drivers, Interrupt Service Routines (ISRs), or other parts of the system. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="srs-qp_ao.html#SRS_QP_AO_70">SRS_QP_AO_70</a>: <em>Active Object abstraction shall provide support for <u>state machines</u>.</em></li>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_CLS">SAS_QP_CLS</a>: <em>QP Framework base classes</em></li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QAsm">SDS_QP_QAsm</a>: <em><a class="el" href="struct_q_asm.html" title="Abstract State Machine class (state machine interface)">QAsm</a> Abstract state machine class.</em><ul>
<li><a class="el" href="struct_q_asm.html">QAsm</a>: <em>Abstract State Machine class (state machine interface)</em></li>
</ul>
</li>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em><ul>
<li><a class="el" href="struct_q_hsm.html#ac7ee65ede9bc841b7b1c4564e13b084d">QHsm::QHsm_ctor()</a>: <em>Constructor of the <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> base class</em></li>
<li><a class="el" href="struct_q_hsm.html#ae69df28aa99b6f9db31a0499e5a52622">QHsm::QHsm_init_()</a>: <em>Implementation of the top-most initial transition in <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_hsm.html#ad12cecce72796450bb7aa75d3af5b305">QHsm::QHsm_dispatch_()</a>: <em>Implementation of dispatching events to a <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_hsm.html#adf9190274fb93b156a6074cd75b81ed5">QHsm::QHsm_isIn_()</a>: <em>Check if a given state is part of the current active state configuration</em></li>
<li><a class="el" href="struct_q_hsm.html#a8b743166d44f6df43568c256b85a6ef4">QHsm::QHsm_state()</a>: <em>Obtain the current active state from a HSM (read only)</em></li>
<li><a class="el" href="struct_q_hsm.html#af03f75d32aa015fb73ed0802813b8fba">QHsm::QHsm_childState()</a>: <em>Obtain the current active child state of a given parent in <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_active.html">QActive</a>: <em>Active object class (based on the <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a26_SRS_5FQP_5FSM_5F01" name="a26_SRS_5FQP_5FSM_5F01"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_01"></a>
SRS_QP_SM_01</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_01</b>: <em>Hierarchical state machines shall maintain their current state between RTC steps.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The main job of a state machine is to "remember" its <a class="el" href="#srs-qp_sm-curr">current state</a> between the RTC steps. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a27_SRS_5FQP_5FSM_5F10" name="a27_SRS_5FQP_5FSM_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_10"></a>
SRS_QP_SM_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_10</b>: <em>QP Framework shall support multiple and interchangeable State Machine Implementation Strategies</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Application can choose the State Machine Implementation Strategy (out of a set of supported strategies) through the <b>type</b> of a state machine object. Based on that type, QP Framework shall then resolve the matching "State Machine Processor" (matching <em>dispatch</em> method) at run-time (e.g., by virtual call). Moreover, QP Framework shall allow Applications to add their State Machine Implementation Strategies, and QP Framework shall still resolve the matching (application-defined) <em>dispatch</em> method based on the type of the state machine object. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Application-defined State Machine Implementation Strategies might be useful for special purposes, such as components with stringent performance requirements (but perhaps fewer state machine features) or test doubles (in TDD). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QAsm">SDS_QP_QAsm</a>: <em><a class="el" href="struct_q_asm.html" title="Abstract State Machine class (state machine interface)">QAsm</a> Abstract state machine class.</em><ul>
<li><a class="el" href="struct_q_asm.html">QAsm</a>: <em>Abstract State Machine class (state machine interface)</em></li>
</ul>
</li>
<li><a class="el" href="struct_q_asm_vtable.html">QAsmVtable</a>: <em>Virtual table for the <a class="el" href="struct_q_asm.html" title="Abstract State Machine class (state machine interface)">QAsm</a> class</em></li>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em><ul>
<li><a class="el" href="struct_q_hsm.html#ac7ee65ede9bc841b7b1c4564e13b084d">QHsm::QHsm_ctor()</a>: <em>Constructor of the <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> base class</em></li>
<li><a class="el" href="struct_q_hsm.html#ae69df28aa99b6f9db31a0499e5a52622">QHsm::QHsm_init_()</a>: <em>Implementation of the top-most initial transition in <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_hsm.html#ad12cecce72796450bb7aa75d3af5b305">QHsm::QHsm_dispatch_()</a>: <em>Implementation of dispatching events to a <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_hsm.html#adf9190274fb93b156a6074cd75b81ed5">QHsm::QHsm_isIn_()</a>: <em>Check if a given state is part of the current active state configuration</em></li>
<li><a class="el" href="struct_q_hsm.html#a8b743166d44f6df43568c256b85a6ef4">QHsm::QHsm_state()</a>: <em>Obtain the current active state from a HSM (read only)</em></li>
<li><a class="el" href="struct_q_hsm.html#af03f75d32aa015fb73ed0802813b8fba">QHsm::QHsm_childState()</a>: <em>Obtain the current active child state of a given parent in <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a></em></li>
<li><a class="el" href="struct_q_active.html">QActive</a>: <em>Active object class (based on the <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#ad91df03146d645017c58b6bb1b7ab57b">QASM_DISPATCH</a>: <em>Virtual call to dispatch an event to a HSM</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a28_SRS_5FQP_5FSM_5F20" name="a28_SRS_5FQP_5FSM_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_20"></a>
SRS_QP_SM_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_20</b>: <em>QP Framework shall provide a State Machine Implementation Strategy optimized for "manual coding"</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">"Optimized for manual coding" means that changing a single element in the state machine design (e.g., nesting of the state hierarchy) should require changing only a single matching element in the implementation. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">The State Machine Implementation Strategy "optimized for manual coding" imposes restrictions on the implementation strategy but does <em>not</em> mean that the code must be written manually. In the presence of a modeling tool, such code can also be generated automatically. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a29_SRS_5FQP_5FSM_5F21" name="a29_SRS_5FQP_5FSM_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_21"></a>
SRS_QP_SM_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_21</b>: <em>QP Framework should provide a State Machine Implementation Strategy optimized for "automatic code generation"</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">"Optimized for automatic code generation" means the implementation may contain some redundant information to improve the <em>efficiency</em> of the state machine execution. Also, such a strategy can support <em>more advanced</em> state machine features (see <a class="el" href="#SRS_QP_SM_21">SRS_QP_SM_21</a>) than a strategy constrained by the limitations of "manual coding" (see <a class="el" href="#SRS_QP_SM_20">SRS_QP_SM_20</a>). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Automatically generated code not intended for manual maintenance allows relaxing the restrictions imposed by "manual coding". In that case, a State Machine Implementation Strategy "optimized for automatic code generation" offers the application developers a choice of higher-performance and/or more features than the strategy "optimized for manual coding." For example, an implementation may contain "transition tables" with information about the chains of state exit and entry actions to execute for a given transition (instead of determining the state exit and entry at run-time). This optimization might require adjusting multiple "transition tables" when changing the hierarchical nesting of a single state, which is considered unsuitable for manual coding (see <a class="el" href="#SRS_QP_SM_20">SRS_QP_SM_20</a>). However, optimization of that kind is trivial for an automatic code generator. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="struct_q_m_state.html">QMState</a>: <em>State object for the <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> class (QM State Machine)</em></li>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em><ul>
<li><a class="el" href="struct_q_msm.html#a57578662c996e851abfca288095c66ec">QMsm::QMsm_init_()</a>: <em>Implementation of the top-most initial transition in <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a></em></li>
<li><a class="el" href="struct_q_msm.html#ace7c7d95fb8b61a04392dc6a58e19add">QMsm::QMsm_dispatch_()</a>: <em>Implementation of dispatching events to a <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a></em></li>
<li><a class="el" href="struct_q_msm.html#aa06eca195b3ef17e2c47c623a9c2cc3c">QMsm::QMsm_isIn_()</a>: <em>Tests if a given state is part of the current active state configuration</em></li>
<li><a class="el" href="struct_q_msm.html#a9cbe8c780a42ee24df328c3e424a4fb1">QMsm::QMsm_getStateHandler_()</a>: <em>Implementation of getting the state handler in a <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> subclass</em></li>
<li><a class="el" href="struct_q_msm.html#ab00fb4ad92ffa3078d8ea589424aacfe">QMsm::QMsm_stateObj()</a>: <em>Obtain the current state from a MSM (read only)</em></li>
<li><a class="el" href="struct_q_msm.html#ab1fc69e61fc0b02272454d2083742a01">QMsm::QMsm_childStateObj()</a>: <em>Obtain the current active child state of a given parent in <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a></em></li>
<li><a class="el" href="struct_q_msm.html#ae3734745028e390aa776e2b59c5716c8">QMsm::QMsm_ctor()</a>: <em>Constructor of <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a></em></li>
<li><a class="el" href="struct_q_msm.html#a6ff149ccff88b2c95397ad95d0cffe0c">QMsm::QMsm_execTatbl_()</a>: <em>Execute transition-action table</em></li>
<li><a class="el" href="struct_q_msm.html#a2ef7b4f64ac958ca4acabfeeffe75f71">QMsm::QMsm_exitToTranSource_()</a>: <em>Exit the current state up to the explicit transition source</em></li>
<li><a class="el" href="struct_q_msm.html#a1c52fe122a207dded015e527e096da0f">QMsm::QMsm_enterHistory_()</a>: <em>Enter history of a composite state</em></li>
<li><a class="el" href="struct_q_m_active.html">QMActive</a>: <em>Active object class (based on <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="struct_q_m_active.html">QMActive</a>: <em>Active object class (based on <a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> implementation strategy)</em><ul>
<li><a class="el" href="struct_q_m_active.html#a75f88fad5134cebe81e883254d4db093">QMActive::QMActive_ctor()</a>: <em>Constructor of <a class="el" href="struct_q_m_active.html" title="Active object class (based on QMsm implementation strategy)">QMActive</a> class</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a30_SRS_5FQP_5FSM_5F22" name="a30_SRS_5FQP_5FSM_5F22"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_22"></a>
SRS_QP_SM_22</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_22</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall be bidirectionally traceable</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Bi-directional traceability of a State Machine Implementation Strategy means that the rules of the "State Machine Specification" are such that:</p><ol type="1">
<li>Each state machine element in the <em>design</em> (in the diagram) is represented by exactly one element in the implementation; and</li>
<li>Each state machine element in the <em>implementation</em> corresponds to exactly one element in the design (diagram). </li>
</ol>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Traceability between design and implementation is a required property for many functional safety standards. Additionally, traceability of state machine implementation is an extremely valuable property is a cornerstone for effective debugging and tracing of state machine execution. For example, traceable implementation allows a developer to set a breakpoint on a specific state transition, state-entry action, a specific guard condition etc. Without a one-to-one traceability between state machine design and code, such elements (e.g., transitions) might be repeated, which would hinder debugging. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a31_SRS_5FQP_5FSM_5F23" name="a31_SRS_5FQP_5FSM_5F23"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_23"></a>
SRS_QP_SM_23</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_23</b>: <em>QP Framework shall ensure that the <u>current event</u> does not change and is accessible to the state machine implementation over the entire RTC step.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The unchangeability of the <a class="el" href="#srs-qp_sm-evt">current event</a> means that both its Signal and Parameters remain unchanged throughout the <a class="el" href="#srs-qp_sm-rtc">RTC step</a> within the state machine. Also the access to the current event should be computationally inexpensive (e.g., via a pointer or a reference to the current event). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">The most important aspect of this requirement is preventing any changes to the current event throughout all RTC steps that the event might be involved in (in case the same event is dispatched to multiple state machines). Also, QP Framework shall make provisions for protecting the current event (e.g., by making it <code>const</code> in the implementation). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a32_SRS_5FQP_5FSM_5F24" name="a32_SRS_5FQP_5FSM_5F24"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_24"></a>
SRS_QP_SM_24</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_24</b>: <em>All State Machine Implementation Strategies provided by QP shall allow Applications to easily access the <u>instance variables</u> associated with a given state machine object</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP framework shall allow for easy and computationally inexpensive access to the internal attributes of the object associated with the state machine from <em>within</em> that object. A good example of implementing such a policy is the concept of class encapsulation in OOP, where the internal attributes are accessible to the class operations (e.g., via the <code>this</code> pointer) and are harder to access from the outside. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">At the same time, QP Framework shall provide <a class="el" href="srs-qp_ao.html#srs-qp_ao-enc">encapsulation</a> of the state machine objects. While QP Framework alone cannot rigorously enforce such encapsulation, the framework should allow the QP Application to hide such access from the <em>outside</em> of the state machine object. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="srs-qp_ao.html#SRS_QP_AO_51">SRS_QP_AO_51</a>: <em>Active Object abstraction shall allow Applications to easily access the internal attributes from inside the Active Object</em></li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a33_SRS_5FQP_5FSM_5F25" name="a33_SRS_5FQP_5FSM_5F25"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_25"></a>
SRS_QP_SM_25</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_25</b>: <em>All State Machine Implementation Strategies provided by QP Framework might supply a method for checking if a state machine is in a given state</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The "is-in" state operation returns 'true' if the <a class="el" href="#srs-qp_sm-curr">current state</a> of the state machine is equal or is a substate of the given state. Otherwise, the "is-in" operation returns 'false'. Please note that in a hierarchical state machine, to "be in a state" means also to be in a superstate of the given state. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">This operation is intended to be used only for state machines that run in the same thread of execution. For example, a given Active Object could use the "is-in" check on one of the "Orthogonal Components" owned by that Active Object. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QAsm">SDS_QP_QAsm</a>: <em><a class="el" href="struct_q_asm.html" title="Abstract State Machine class (state machine interface)">QAsm</a> Abstract state machine class.</em><ul>
<li><a class="el" href="struct_q_asm.html">QAsm</a>: <em>Abstract State Machine class (state machine interface)</em></li>
</ul>
</li>
<li><a class="el" href="struct_q_hsm.html#adf9190274fb93b156a6074cd75b81ed5">QHsm::QHsm_isIn_()</a>: <em>Check if a given state is part of the current active state configuration</em></li>
<li><a class="el" href="struct_q_msm.html#aa06eca195b3ef17e2c47c623a9c2cc3c">QMsm::QMsm_isIn_()</a>: <em>Tests if a given state is part of the current active state configuration</em></li>
<li><a class="el" href="qp_8h.html#a9f21f71882bd92ecb905be8d828be2d5">QASM_IS_IN</a>: <em>Virtual call to check whether a SM is in a given state</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a34_SRS_5FQP_5FSM_5F30" name="a34_SRS_5FQP_5FSM_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_30"></a>
SRS_QP_SM_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_30</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>hierarchical state machines</u> with features specified in the sub-requirements SRS_QP_SM_3x</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The state diagram shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a> below demonstrates a Hierarchical State Machine with all features that need to be supported by all State Machine Implementation Strategies provided in QP Framework: <a class="anchor" id="srs-qp_sm-fig-hsm"></a></p><div class="image">
<img src="srs-qp_sm-hsm.png" alt="" width="1500px"/>
</div>
  <div class="caption"><center><em>Figure SRS-SM-HSM: Hierarchical State Machine diagram with labeled features corresponding to the sub-requirements</em></center></div> </td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">The hierarchical state machine shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a>, demonstrates only a <b>subset of features</b> found in UML Statecharts <a class="el" href="srs-qp.html#srs-qp_ref">[UML-05]</a>. Most notably, the UML Statecharts features <b>not</b> supported in the QP Framework include "orthogonal regions" and several kinds of "pseudostates". </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a35_SRS_5FQP_5FSM_5F31" name="a35_SRS_5FQP_5FSM_5F31"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_31"></a>
SRS_QP_SM_31</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_31</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>states</u> capable of holding hierarchically nested substates</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">An example state is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [A]</a>. This is a <em>composite</em> state because it holds other states (called substates). A state that holds no other states is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [A1]</a>. Such a state is called a <em>leaf</em> state. The State Machines Implementation Strategies in QP need to represent both types of states. Moreover, it should be possible to simply add substates to a given state thus making it a composite state as well as remove substates, thus making it a leaf state. Also, it should be possible to simply change the nesting of a given state from one superstate to another (including moving it to the implicit "top" superstate). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a>: <em>Designates the superstate of a given state. Applicable only to <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> subclasses</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a36_SRS_5FQP_5FSM_5F32" name="a36_SRS_5FQP_5FSM_5F32"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_32"></a>
SRS_QP_SM_32</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_32</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>entry actions</u> to states</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Example entry actions to a state are shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [B]</a>. Entry actions to a state are optional, meaning that a given state might specify entry actions or not. If any entry actions are defined in a given state, the State Machine Processor in QP must execute these actions whenever that state is entered. Also, entry actions to superstates must be always executed <em>before</em> entry actions to substates. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Entry actions to a state provide an important mechanism to initialize that state context and QP must guarantee such initialization on any transition path leading to a given state. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>: <em>Indicate that an action has been "handled". Applies to entry/exit actions and to internal transitions</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a37_SRS_5FQP_5FSM_5F33" name="a37_SRS_5FQP_5FSM_5F33"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_33"></a>
SRS_QP_SM_33</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_33</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>exit actions</u> from states</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Example exit actions from a state are shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [C]</a>. Exit actions from a state are optional, meaning that a given state might specify exit actions or not. If any exit actions are defined in a given state, the State Machine Processor in QP must execute these actions whenever that state is exited. Also, exit actions to superstates must be always executed <em>after</em> exit actions from substates. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Exit actions from a state provide an important mechanism to cleanup that state context, and QP must guarantee such cleanup on any transition path leading out of a given state. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>: <em>Indicate that an action has been "handled". Applies to entry/exit actions and to internal transitions</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a38_SRS_5FQP_5FSM_5F34" name="a38_SRS_5FQP_5FSM_5F34"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_34"></a>
SRS_QP_SM_34</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_34</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>nested initial transitions</u> in composite states</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">An example nested initial transition is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [D]</a>. A composite can have at most one initial transition nested directly in that state. The nested initial transition can have actions and can target any direct substate or indirect substate of the parent state (at a deeper level of state nesting). If a given state has an initial transition and other transition (regular or initial) targets that state, QP must execute the initial transition.</p>
<p class="intertd"><b>Initial Transition Execution Sequence</b><br  />
 The execution sequence of nested initial transition is as follows:</p><ol type="1">
<li>actions associated with the initial transition;</li>
<li>entry actions to the target state configuration, starting with the states at the highest levels of nesting;</li>
<li>if the main target state of the initial transition contains its nested initial transition, it should be executed according to the same rules, applied recursively.</li>
</ol>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Examples</b><br  />
</p>
<p class="intertd">The execution sequence for the initial transition nested directly in state "s2" in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a> is as follows:<br  />
 <code>s2_init(); s22_entry(); s22_init(); s211_entry();</code></p>
<p class="intertd">On the other hand, the execution sequence for the initial transition nested directly in state "s1" in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a> is as follows:<br  />
 <code>s1_init(); s12_entry(); s121_entry();</code></p>
<dl class="section note"><dt>Note</dt><dd>It is also legal in QP to have a composite state with substates, but <em>without</em> a nested initial transition. If such a composite state is the main target of a state transition, the state becomes the <em>current state</em>, without any of its substates becoming active. </dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a39_SRS_5FQP_5FSM_5F35" name="a39_SRS_5FQP_5FSM_5F35"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_35"></a>
SRS_QP_SM_35</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_35</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>transitions</u> between states at any level of nesting</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">An example of a transition is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [E]</a>. A transition in QP must have an <b>explicit trigger</b>, which is the <a class="el" href="srs-qp_evt.html#srs-qp_evt-sig">Signal</a> of the event that triggered the transition.</p>
<p class="intertd"><b>Main-Source State</b><br  />
 The state where the transition originates is called the <em>main-source</em> and in QP this main-source state "owns" the transition. Please note that the main-source state might be different from the current state when the transition is "inherited" from a higher-level state.<br  />
</p>
<p class="intertd"><b>Main-Target State</b><br  />
 The state where the transition terminates is called the <em>main-target</em>. Please note that the main-target state might be different from the new current state after the transition when the main-target state is composite and contains a nested initial transition.</p>
<p class="intertd"><b>Self-Transition</b><br  />
 In a special case of the main source being the same as the main target (see <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [E1]</a>), the transition is called <em>self-transition</em>.</p>
<p class="intertd"><b>Transition Execution Sequence</b><br  />
 The execution sequence of a state transition is as follows:</p><ol type="1">
<li>Actions associated with the transition, which might include the whole <a class="el" href="#srs-qp_02_37-eval">guard evaluation sequence</a>;</li>
<li>Exit actions from the source state configuration, starting with the states at the lowest levels of nesting, up to the <code>LCA(main-source, main-target)</code> state, whereas <code>LCA(s1, s2)</code> denotes the state that is the Least Common Ancestor of states <code>s1</code> and <code>s2</code>, based on the state containment hierarchy.</li>
<li>Entry actions to the target state configuration, starting with the states at the highest levels of nesting. If the main-target state contains a nested initial transition, it should be executed according to the rules described in <a class="el" href="#SRS_QP_SM_34">SRS_QP_SM_34</a>.</li>
</ol>
<p class="intertd">In most state transitions, the main-source state is exited, and the main target is entered. The only exceptional cases are explained below:</p>
<p class="intertd"><b>Local State Transition Semantics</b><br  />
 <em>Special Case 1:</em> If the main-source state of the transition contains the main-target state (e.g., transition E3 in state "s1" in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a>), the main-source state is <em>not</em> exited.</p>
<p class="intertd"><em>Special Case 2:</em> If the main-target state contains the main_source (e.g., transition E2 in state "s121" in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a>), the main-target is <em>not</em> entered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In the UML Specification <a class="el" href="srs-qp.html#srs-qp_ref">[UML-2.5]</a>, Special Cases 1 and 2 correspond to the <b>local state transition</b> semantics. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The transition execution sequence in QP <a class="el" href="srs-qp.html#srs-qp_ref">[PSiCC2:08]</a> is <em>different</em> than in the UML Specification <a class="el" href="srs-qp.html#srs-qp_ref">[UML-2.5]</a>, because the <a class="el" href="#srs-qp_02_37-eval">guard evaluation sequence</a> is executed in QP <em>before</em> the exit from the source state configuration and entry to the target state configuration. It is necessary first to determine the main-target state of the transition based on the evaluation of guards. The guards' evaluation might also determine that the event is to be propagated to the higher-level states, or that only an internal transition should be executed, in which cases no states should be exited or entered at all. In the UML Specification <a class="el" href="srs-qp.html#srs-qp_ref">[UML-2.5]</a>, transition actions are executed <em>after</em> exiting the source state configuration but <em>before</em> entering the target state configuration, which immensely complicates the semantics and implementation of guards.</dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Examples</b><br  />
</p>
<p class="intertd">Assuming that "s222" is the current state, the execution sequence for the transition s22:E2 (see <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM[E]</a>) is as follows:<br  />
 <code>s22_E2(); s222_exit(); s22_exit(); s2_exit(); s1_entry(); s1_init(); s12_entry(); s121_entry();</code></p>
<p class="intertd">Assuming that "s121" is the current state, the execution sequence for the transition s1:E3 (Special Case 1) is as follows:<br  />
 <code>s1_E3(); s121_exit(); s12_exit(); s12_entry(); s121_entry();</code><br  />
</p>
<p class="intertd">Assuming that "s121" is the current state, the execution sequence for the transition s121:E1 (Special Case 2) is as follows:<br  />
 <code>s121_E2(); s121_exit(); s12_exit(); s1_init(); s12_entry(); s121_entry();</code><br  />
</p>
<p class="intertd">Assuming that "s222" is the current state, the execution sequence for the self-transition s22:E1 in (see <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM[E1]</a>) is as follows:<br  />
 <code>s22_E1; s222_exit(); s22_exit(); s22_entry(); s22_init(); s221_entry();</code></p>
<dl class="section note"><dt>Note</dt><dd>In a self-transition, the main-source <b>is</b> exited, and the main-target (same as main-source) <em>is</em> entered. Thus self-transition becomes an idiom for resetting a given state context by cleanly exiting and re-entering a given state. </dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a40_SRS_5FQP_5FSM_5F36" name="a40_SRS_5FQP_5FSM_5F36"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_36"></a>
SRS_QP_SM_36</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_36</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>internal transitions</u> in states</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">An example of an internal transition is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [F]</a>. This type of transition causes only the execution of the associated actions. Still, it never leads to a change of the current state, and consequently, it never causes execution of any state exit or state entry actions. An alternative name for internal transition is a *state reaction_. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">Internal transitions (state reactions) are very common in practice. Internal transitions are also different from self-transitions because an internal transition never causes execution of any state exit or state entry actions. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>: <em>Indicate that an action has been "handled". Applies to entry/exit actions and to internal transitions</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a41_SRS_5FQP_5FSM_5F37" name="a41_SRS_5FQP_5FSM_5F37"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_37"></a>
SRS_QP_SM_37</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_37</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>guard conditions</u> to be attached to regular and internal transitions</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">An example of a transition with an attached guard condition is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [G]</a>. A <em>guard condition</em> (or simply *guard_) is a Boolean expression that disables a given transition path when it evaluates to FALSE. In QP, guard conditions are always "attached" to a transition via a choice pseudostate (UML Specification <a class="el" href="srs-qp.html#srs-qp_ref">[UML-2.5]</a>). A given choice pseudostate may have multiple attached guards, each starting a separate transition path and associated with its own (optional) action.</p>
<p class="intertd"><b>Disabled Transitions</b><br  />
 If all guards attached to a transition (via a choice pseudostate) evaluate to FALSE, the whole transition is <em>disabled</em>. Such a transition shall be treated as though it was not present, so the triggering event is propagated to the higher-level states in the state hierarchy.</p>
<p class="intertd"><a class="anchor" id="srs-qp_02_37-eval"></a><b>Guard Evaluation</b><br  />
 Conceptually, you can think of a choice pseudostate and the attached guard conditions as an <code>if-then-else</code> sequence. Each guard is evaluated <em>dynamically</em> when the control reaches the guard in that sequence. For example, the following pseudocode shows the sequence for the transition s2:E2 (<a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [E2]</a>):</p>
<div class="fragment"><div class="line">s2_E2();               <span class="comment">// action associated with the original transition</span></div>
<div class="line"><span class="keywordflow">if</span> (g1()) {            <span class="comment">// evaluate guard g1()</span></div>
<div class="line">   s2_E2_g1();         <span class="comment">// action associated with the path following [g1()]</span></div>
<div class="line">   transition_to(s1);  <span class="comment">// regular state transition</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (g2()) {       <span class="comment">// evaluate guard g2()</span></div>
<div class="line">   s2_E2_g2();         <span class="comment">// action associated with the path following [g2()]</span></div>
<div class="line">   internal_transition(); <span class="comment">// internal state transition</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {                 <span class="comment">// disabled transition</span></div>
<div class="line">   propagate_to_superstate(top); <span class="comment">// event not handled at this level</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#srs-qp_02_37-eval">guard evaluation sequence</a> determines the <b>main-target</b> of the transition. For example, in the guard evaluation sequence shown above, if the guard <code>g1()</code> evaluates to TRUE, the main target is set to state "s1". Otherwise, if <code>g2()</code> evaluates to TRUE, the main target will not be set, and the <a class="el" href="#srs-qp_sm-proc">State Machine Specification</a> will return status to the <a class="el" href="#srs-qp_sm-proc">QP State Machine Processor</a> to indicate only an <a class="el" href="#SRS_QP_SM_36">internal transition</a>. Otherwise, if both <code>g1()</code> and <code>g2()</code> evaluate to FALSE, the whole transition is considered <em>disabled</em>, and the <a class="el" href="#srs-qp_sm-proc">State Machine Specification</a> will return status to the <a class="el" href="#srs-qp_sm-proc">QP State Machine Processor</a> to propagate the event to the higher-level state.</dd></dl>
<p><b>The Complementary [else] Guard</b><br  />
 QP shall also support the special, complementary guard <code>[else]</code> (see <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [G1]</a>), which will explicitly complement all other guards attached to the same choice pseudostate. For example, the following pseudocode shows the sequence for the transition s1:E3 (<a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM</a>):</p>
<div class="fragment"><div class="line">s1_E3();               <span class="comment">// action associated with the original transition</span></div>
<div class="line"><span class="keywordflow">if</span> (g3()) {            <span class="comment">// evaluate guard g3()</span></div>
<div class="line">   s1_E3_g3();         <span class="comment">// action associated with the path following [g3()]</span></div>
<div class="line">   transition_to_deep_history_of(s22); <span class="comment">// transition to history (deep)</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {                 <span class="comment">// explicit complementary [else] guard</span></div>
<div class="line">   s1_E3_else();       <span class="comment">// action associated with the path following [else]</span></div>
<div class="line">   transition_to(s21); <span class="comment">// regular state transition</span></div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a42_SRS_5FQP_5FSM_5F38" name="a42_SRS_5FQP_5FSM_5F38"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_38"></a>
SRS_QP_SM_38</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_38</b>: <em>All State Machine Implementation Strategies provided by QP Framework shall support <u>top-most initial transition</u> that shall be explicitly triggered independently from instantiation of the state machine object</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">An example top-most initial transition is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [I]</a>. The top-most initial transition has the same semantics as nested initial transitions (see <a class="el" href="#SRS_QP_SM_34">SRS_QP_SM_34</a>) except the top-most initial transition nests in the implicit "top" superstate and it is mandatory rather than optional.</p>
<p class="endtd">The execution of the top-most initial transition is intentionally separated from the instantiation of the state machine object, to allow applications to fully control the initialization performed in the actions to the top-most initial transition. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">The instantiation of state machine objects might occur in an undefined order, even before the entry point into the application (before the <code>main()</code> function in C++). This is typically before the target hardware or the underlying real-time kernel has been properly initialized. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#a2f7948a81873c2e235283c8aa0988002">QASM_INIT</a>: <em>QVirtual call to the top-most initial transition in a HSM</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a43_SRS_5FQP_5FSM_5F39" name="a43_SRS_5FQP_5FSM_5F39"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_39"></a>
SRS_QP_SM_39</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_39</b>: <em>All State Machine Implementation Strategies provided by QP Framework should support <u>transitions to history</u>. Both shallow and deep histories shall be supported</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">An example of a transition to <em>deep history</em> is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [H1]</a>. An example of a transition path to <em>shallow history</em> is shown in <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [H2]</a>. Transitions to history (deep or shallow) apply only to composite states and represent the most recently active substate. In the case of deep history, the actual current substate is remembered upon the exit from the given composite state. In the case of shallow history, only the direct substate containing the current substate is remembered. Transition to state history means transitioning to that remembered substate. Upon initialization, when a given composite state has never been active before, the transition to history is initialized with the <em>default history</em>, which is the substate pointed to by the transition coming out of the history circle (e.g., <a class="el" href="#srs-qp_sm-fig-hsm">Figure SRS-SM-HSM [H1]</a>). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">To support transitions to history, QP Framework needs to supply a mechanism to access the current state (deep history) and the direct substate of the current state. This information needs to be stored upon the exit of a given composite state. Also, the QP Framework needs to transition dynamically to the stored history substate. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="qp_8h.html#ac927f38462ffb9c8cca4e4f2920f8fcd">Q_TRAN_HIST</a>: <em>Take transition to the specified history of a given state. Applicable only to HSMs</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a44_SRS_5FQP_5FSM_5F40" name="a44_SRS_5FQP_5FSM_5F40"></a> </p>
<h2><a class="anchor" id="SRS_QP_SM_40"></a>
SRS_QP_SM_40</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_SM_40</b>: <em>State Machine Implementation Strategies provided by QP Framework might supply the <u>top-state</u></em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The <em>top-state</em> is the ultimate root of state hierarchy and typically it is not rendered in the state diagrams. However, the concept can be useful in State Machine Specification as the superstate of states not nested in any other state. In case a given State Machine Implementation Strategy uses the concept of the top-state, QP Framework may provide a top-state element with the default behavior of silently ignoring all events. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QHsm">SDS_QP_QHsm</a>: <em><a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class (QHsm-style state machine implementation strategy)">QHsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_hsm.html">QHsm</a>: <em>Hierarchical State Machine class (QHsm-style state machine implementation strategy)</em></li>
</ul>
</li>
<li><a class="el" href="sds-qp_struct.html#SDS_QP_QMsm">SDS_QP_QMsm</a>: <em><a class="el" href="struct_q_msm.html" title="Hierarchical State Machine class (QMsm-style state machine implementation strategy)">QMsm</a> State machine class.</em><ul>
<li><a class="el" href="struct_q_msm.html">QMsm</a>: <em>Hierarchical State Machine class (QMsm-style state machine implementation strategy)</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_evt.html">Events</a></span><span class="next_button"><a class="el" href="srs-qp_edm.html">Event Delivery Mechanisms</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

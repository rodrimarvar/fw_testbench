<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Preemptive Non-Blocking Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_qk.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Preemptive Non-Blocking Kernel</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_qv.html">Non-Preemptive Kernel</a></span><span class="next_button"><a class="el" href="srs-qp_qxk.html">Preemptive Dual-Mode Kernel</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_qk-intro"></a>
Concepts &amp; Definitions</h1>
<p>The <a class="el" href="srs-qp_ao.html#srs-qp_ao-model">Active Object model of computation</a> can work with a wide range of real-time kernels. Specifically for the kernel discussed in this section, the <a class="el" href="srs-qp_ao.html#srs-qp_ao-block">non-blocking</a> and <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">run-to-completion</a> characteristics of the Active Object model open up a possibility of using a <em>non-blocking</em>, run-to-completion kernel. Such a kernel can be <b>preemptive</b> and fully compatible with the requirements of Rate Monotonic Scheduling/Analysis (RMS/RMA) method <a class="el" href="srs-qp.html#srs-qp_ref">[RMS/RMA:91]</a>. Still, a non-blocking kernel is much simpler and significantly more efficient than any traditional blocking RTOS kernel.</p>
<h2><a class="anchor" id="srs-qp_qk-def"></a>
QK Preemptive Non-Blocking Kernel</h2>
<p>QK is a preemptive, non-blocking, fixed-priority, run-to-completion, single-stack, event-driven kernel integrated with the QP Framework. QK executes all Active Objects in discrete, one-shot, non-blocking <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC steps</a> that can <b>preempt</b> each other. This preemption is similar to how prioritized interrupts can preempt each other and nest on a <b>single stack</b> (e.g., see description of interrupt handling in ARM Cortex-M <a class="el" href="srs-qp.html#srs-qp_ref">[Yiu:14]</a>). Interrupts, just like <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC steps</a> in Active Objects, are also one-shot, run-to-completion steps that are not allowed to block.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The one-shot, run-to-completion, non-blocking, preemptible schedulable units of work are known in the literature as "jobs" (Stack Resource Policy <a class="el" href="srs-qp.html#srs-qp_ref">[SRP:90]</a>) or "basic tasks" (OSEK/AUTOSAR terminology <a class="el" href="srs-qp.html#srs-qp_ref">[OSEK:03]</a>). Similar concepts are also called "fibers" (e.g., Q-Kernel), "deferred interrupts" (e.g., SMX kernel), or "software interrupts" (e.g., TI-RTOS).</dd></dl>
<h2><a class="anchor" id="srs-qp_qk-pre"></a>
Preemptions in QK</h2>
<p>As a fully <em>preemptive</em>, fixed-priority kernel, QK must ensure that at all times the CPU executes the highest-priority Active Object (AO) as soon as it <em>becomes ready</em> to run. Fortunately, only two scenarios can lead to preemption of a lower-priority AO1 by a higher-priority AO2.</p>
<dl class="section note"><dt>Note</dt><dd>The QK kernel is one of the simplest and most efficient kernels fully compatible with RMS/RMA/DMS. Due to the simplicity, the QK kernel is a <em>recommended</em> choice for <b>safety-critical</b> applications.</dd></dl>
<p><a class="anchor" id="qk-synch"></a><b>Synchronous Preemption</b><br  />
 When a lower-priority AO1 posts an event to a higher-priority AO2, the QK kernel must immediately suspend the execution of the lower-priority AO1 and start the higher-priority AO2. This type of preemption is called <b>synchronous preemption</b> because it happens synchronously with posting an event to the AO2's event queue.</p>
<p><a class="anchor" id="srs-qp_fig-qk-syn"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qk-syn.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QK-SYN: Synchronous Preemption in QK. The stack is shown in the bottom panel grows "down" (as on ARM Cortex-M).</em></center></div><p><a class="el" href="#srs-qp_fig-qk-syn">Figure SRS-QK-SYN</a> illustrates a <b>synchronous preemption</b> scenario:</p>
<p><code>[1]</code> QK idle loop (QK idle task) is preempted by an AO1, which executes its RTC step</p>
<p><code>[2]</code> AO1 posts an event to a higher-priority AO2, which calls the "QK activator"</p>
<p><code>[3]</code> "QK activator" activates (calls) the AO2 RTC step</p>
<p><code>[4]</code> AO2 RTC step completes and returns to the "QK activator"</p>
<p><code>[5]</code> "QK activator" returns back to AO1, which remained <em>synchronously</em> preempted</p>
<p><code>[6]</code> AO1 completes its RTC step and returns to "QK activator" (previous instance)</p>
<p><code>[7]</code> "QK activator" finds no more AOs to run and returns to the QK idle loop.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A traditional RTOS kernel does not distinguish between the synchronous and asynchronous preemptions (see next) and makes all preemptions look like the more stack-intensive asynchronous preemptions. In contrast, a run-to-completion kernel like QK can implement synchronous preemption as a simple function call, which is more efficient than a full context-switch.</dd></dl>
<p><a class="anchor" id="qk-asynch"></a><b>Asynchronous Preemption</b><br  />
 When an <em>interrupt</em> posts an event to a higher-priority AO2 than the interrupted AO1, upon completion of the ISR the QK kernel must start execution of the higher-priority AO2 instead of resuming the lower-priority AO1. This type of preemption is called <b>asynchronous preemption</b> because it can happen asynchronously, any time interrupts are not explicitly disabled.</p>
<p><a class="anchor" id="srs-qp_fig-qk-asn"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qk-asn.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QK-ASN: Asynchronous Preemption in QK. The stack is shown in the bottom panel grows "down" (as on ARM Cortex-M).</em></center></div><p><a class="el" href="#srs-qp_fig-qk-asn">Figure SRS-QK-ASN</a> illustrates an <b>asynchronous preemption</b> scenario:</p>
<p><code>[1]</code> QK idle loop (QK idle task) is preempted by an AO1, which executes its RTC step</p>
<p><code>[2]</code> An interrupt fires and asynchronously preempts the AO1 RTC step</p>
<p><code>[3]</code> The ISR for the interrupt starts running and posts an event to high-priority AO2</p>
<p><code>[4]</code> The ISR sends the EOI (End-of-Interrupt) command to the interrupt-controller, but does NOT return to the preempted context (so the interrupt stack frame remains on the stack). Instead, the ISR calls "QK activator". </p><dl class="section remark"><dt>Remarks</dt><dd>The details of this step depend on the CPU and interrupt controller and might be more complex. For example ARM Cortex-M CPU requires additional step of activating the PendSV exception.)</dd></dl>
<p><code>[5]</code> "QK activator" activates (calls) the AO2 RTC step</p>
<p><code>[6]</code> AO2 RTC step completes and returns to the "QK activator"</p>
<p><code>[7]</code> "QK activator" performs <b>interrupt</b>-return back to AO1, which remained <em>asynchronously</em> preempted</p>
<p><code>[8]</code> AO1 completes its RTC step and returns to "QK activator" (previous instance)</p>
<p><code>[9]</code> "QK activator" finds no more AOs to run and returns to the QK idle loop.</p>
<h2><a class="anchor" id="srs-qp_qk-stack"></a>
Single-Stack Kernel</h2>
<p>By requiring that all AOs run-to-completion and enforcing fixed-priority scheduling, a non-blocking kernel like QK can manage all context information using only a <b>single stack</b> and the CPU's <em>natural stack protocol</em>. Whenever an AO posts an event to a higher-priority AO, QK kernel uses a regular C function call to build the higher-priority AO context on top of the existing stack context (<a class="el" href="#qk-synch">synchronous preemption</a>). Whenever an interrupt preempts an AO and the interrupt posts an event to a higher-priority AO, the QK kernel uses the already established interrupt stack frame on top of which to build the higher-priority AO context, again using a regular C function call (<a class="el" href="#qk-asynch">asynchronous preemption</a>).</p>
<p>This simple form of context management is adequate because every AO, just like every ISR, runs to completion. Because the preempting AO must also run to completion, the lower-priority context will never be needed until the preempting AO (and any higher-priority AO that might preempt it) has completed and returned &mdash; at which time the preempted AO will, naturally, be at the top of the stack, ready to be resumed.</p>
<h2><a class="anchor" id="srs-qp_qk-idle"></a>
Idle Processing in QK</h2>
<p>The situation when QK kernel finishes processing all <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC steps</a> in all Active Objects is called the <b>idle condition</b>. In that case, the QK kernel executes <em>idle processing</em>. Idle processing in QK can be viewed as the lowest-priority task (of priority 0), but unlike all other one-shot tasks, it has a structure of an <em>endless loop</em> (see "QK idle loop" in <a class="el" href="#srs-qp_fig-qk-syn">Figure SRS-QK-SYN</a> and <a class="el" href="#srs-qp_fig-qk-asn">Figure SRS-QK-ASN</a>).</p>
<p>This QK idle loop invokes a QK-idle-callback defined in the application, to let the application, among others, put the CPU and peripherals in a <em>low-power sleep mode</em>. Existence of such a single point to apply low-power modes is a hallmark of a <b>power-friendly architecture</b>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The QK-idle-callback is invoked with interrupts enabled because transition to a sleep mode in a <em>preemptive</em> QK kernel is safe form the hazards described for the <a class="el" href="srs-qp_qv.html#srs-qp_qv-idle">non-preemptive QV kernel</a>.</dd></dl>
<h2><a class="anchor" id="srs-qp_qk-lock"></a>
Selective Scheduler Locking</h2>
<p>As all <em>preemptive</em> kernels, QK requires the QP Application to be very careful with any resource sharing among Active Objects. Ideally, the Active Objects should communicate exclusively via events and otherwise should <a class="el" href="srs-qp_ao.html#srs-qp_ao-sharing">not share</a> any resources. However, at the cost of increased coupling among Active Objects, QP Application might choose to share selected resources. However, such QP Application takes the burden on itself to apply a <b>mutual exclusion mechanism</b> while accessing any shared resources.</p>
<p>QK kernel provides <b>selective scheduler locking</b> as a powerful mutual exclusion mechanism. Specifically, before accessing a shared resource, an Active Objects can <b>lock</b> the QK scheduler up to the specified <em>priority ceiling</em>. This prevents Active Object preemption up to the specified <em>priority ceiling</em>, while not affecting Active Objects (or interrupts) of priority higher than the <em>priority ceiling</em>. After accessing the shared resource the Active Object must <b>unlock</b> the QK scheduler. Selective scheduler locking in QK is related to IPCP/SRP (Immediate Priority Ceiling Protocol/Stack Resource Policy) and is immune to unbound priority inversion <a class="el" href="srs-qp.html#srs-qp_ref">[SRP:90]</a>.</p>
<p>Selective scheduling locking is a <em>non-blocking</em> mechanism. If an Active Object that needs to protect a shared resource is running, it means that all Active Objects of higher priority have no events to process. Consequently, simply preventing activation of higher-priority AOs that might access the resource is sufficient to guarantee the mutually exclusive access to the resource. Of course, you don't need to worry about any lower-priority AOs that might be preempted because they never resume until the current AO runs to completion.</p>
<p>Selective scheduler lock requests made by the same Active Object <em>can nest</em>. The nested lock requests can only increase the priority ceiling. Also, the nested lock requests must unlock the scheduler by <em>restoring</em> the previous priority ceiling.</p>
<h2><a class="anchor" id="srs-qp_qk-pts"></a>
Preemption-Threshold Scheduling</h2>
<p>While preemption is a desirable property that enables techniques like RMS/RMA by decoupling higher-priority Active Objects from lower-priority ones in the <em>time domain</em>, too much preemption has also negative effects. These include the overhead of preemption and restrictions on sharing resources. For example, sometimes a group of Active Objects forms a cohesive subsystem, where preemption of one group member by another might be unnecessary and undesirable.</p>
<p>To ease some of the inherent problems of preemption, QK provides and advanced feature called <b>preemption threshold scheduling</b> (PTS), <a class="el" href="srs-qp.html#srs-qp_ref">[PTS:07]</a>. PTS allows an Active Object to specify a <em>preemption threshold</em> to selectively <b>restrict preemption</b> by other Active Objects. Active Objects that have priorities higher than the <em>preemption threshold</em> are still allowed to preempt, while those less than the threshold are not allowed to preempt.</p>
<p>For example, all Active Objects in a group might specify the same <em>preemption threshold</em> (alongside their unique priorities). Such <em>preemption threshold</em> will prevent preemption within the group, while still allowing preemption by other Active Objects with higher priorities than the <em>preemption threshold</em>.</p>
<h2><a class="anchor" id="srs-qp_qk-rt"></a>
Task-Level Response</h2>
<p>The maximum time an event for the highest-priority Active Object can be delayed is called the <em>task-level response</em>. The preemptive QK kernel always executes the highest-priority Active Object <em>immediately</em> as it becomes ready to run (see <a class="el" href="#srs-qp_qk-pre">Preemptions in QK</a>). Therefore, the task-level response in the QK kernel is determined only by the context switch time, which is independent on the lower-priority Active Objects. That is what is meant that a preemptive kernel decouples tasks in the time domain.</p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="#srs-qp_qk-lock">Selective scheduler locking</a> and <a class="el" href="#srs-qp_qk-pts">preemption-threshold scheduling</a> re-introduce some time-domain coupling among Active Objects and can also negatively impact the task level response of the QK kernel.</dd></dl>
<p>As a preemptive kernel with fixed-priority scheduling, QK fulfills all requirements of the Rate Monotonic Scheduling/Analysis (RMS/RMA) <a class="el" href="srs-qp.html#srs-qp_ref">[RMS/RMA:91]</a> and the related Deadline-Monotonic Scheduling (DMS) <a class="el" href="srs-qp.html#srs-qp_ref">[RMS/RMA:91][DMS:91]</a>. Additionally, the no-blocking nature of QK makes the applications easier to analyze and thus actually even more suitable for RMS/RMA than a traditional blocking RTOS.</p>
<h1><a class="anchor" id="srs-qp_qk-req"></a>
Requirements</h1>
<p><a id="a86_SRS_5FQP_5FQK_5F00" name="a86_SRS_5FQP_5FQK_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_00"></a>
SRS_QP_QK_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_00</b>: <em>QP Framework shall provide preemptive non-blocking QK kernel as one of the built-in kernels.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework shall provide QK kernel implementation and ports to the supported CPU/compiler combinations as one of the optional software components. QP Application can then choose the QK kernel to execute Active Objects. Such a selection is exclusive, meaning that when QP Application selects the QK kernel, other kernels are excluded and cannot be used. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework can implement the QK kernel component by re-using already existing mechanisms, such as event queues for Active Objects, event delivery mechanisms, event memory management, etc. That way, the QK kernel implementation can be quite small and consist only of the missing pieces, such as the QK scheduler and "activator". </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a87_SRS_5FQP_5FQK_5F10" name="a87_SRS_5FQP_5FQK_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_10"></a>
SRS_QP_QK_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_10</b>: <em>QK kernel shall provide an idle-callback defined in QP Application.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">When QK kernel finishes processing all <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC steps</a> in all Active Objects it shall execute the <a class="el" href="#srs-qp_qk-idle">QK idle loop</a>. This <em>QK idle loop</em> shall invoke an <b>idle-callback</b> (a function) defined in QP Application. The <em>idle-callback</em> can perform any processing, including putting the CPU and peripherals in a low-power sleep mode. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The <em>idle-callback</em> shall be invoked with interrupts enabled and can perform <a class="el" href="srs-qp_qs.html">Software Tracing</a> data transfer to the host, or other processing. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a88_SRS_5FQP_5FQK_5F20" name="a88_SRS_5FQP_5FQK_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_20"></a>
SRS_QP_QK_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_20</b>: <em>QK kernel shall provide API to selectively lock scheduling Active Objects below the specified scheduler-lock ceiling priority.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The <a class="el" href="#srs-qp_qk-lock">selective scheduler locking</a> API shall prevent scheduling any Active Objects whose <a class="el" href="srs-qp_ao.html#srs-qp_ao-prio">unique priority</a> is below the specified <em>scheduler-lock ceiling priority</em>. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The main use case for selective scheduler locking is during <em>multicasting events</em> to prevent unexpected and confusing event sequences (see <a class="el" href="srs-qp_edm.html#SRS_QP_EDM_55">SRS_QP_EDM_55</a>). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a89_SRS_5FQP_5FQK_5F21" name="a89_SRS_5FQP_5FQK_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_21"></a>
SRS_QP_QK_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_21</b>: <em>QK kernel shall provide API to unlock scheduling Active Objects.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The scheduler unlocking API shall complement the scheduler locking API (see <a class="el" href="#SRS_QP_QK_20">SRS_QP_QK_20</a>). The scheduler unlocking API shall restore the <em>scheduler-lock ceiling</em> established in the most recent call to the scheduler locking API. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The main use case for selective scheduler locking (matching the use case in <a class="el" href="#SRS_QP_QK_20">SRS_QP_QK_20</a>) is enabling the QV scheduler in the system clock tick. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a90_SRS_5FQP_5FQK_5F30" name="a90_SRS_5FQP_5FQK_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_30"></a>
SRS_QP_QK_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_30</b>: <em>QK kernel shall support preemption-threshold scheduling (PTS).</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for <a class="el" href="#srs-qp_qk-pts">preemption-threshold scheduling (PTS)</a> means that each Active Object can be assigned a <em>preemption-threshold</em> (alongside its <a class="el" href="srs-qp_ao.html#srs-qp_ao-prio">unique %QP priority</a>). The Active Object with a given <em>preemption-threshold</em> cannot be preempted by Active Objects with the unique QP priorities below the <em>preemption threshold</em>. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a91_SRS_5FQP_5FQK_5F31" name="a91_SRS_5FQP_5FQK_5F31"></a> </p>
<h2><a class="anchor" id="SRS_QP_QK_31"></a>
SRS_QP_QK_31</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QK_31</b>: <em>The preemption-threshold assigned to an Active Object must be consistent with its unique QP priority.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The <em>preemption-threshold</em> assigned to an Active Object can be only higher than the unique QP priority. Additionally, the <em>preemption-threshold</em> cannot exceed <em>preemption thresholds</em> assigned to any higher-priority Active Objects. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_qv.html">Non-Preemptive Kernel</a></span><span class="next_button"><a class="el" href="srs-qp_qxk.html">Preemptive Dual-Mode Kernel</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

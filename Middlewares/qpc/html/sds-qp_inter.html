<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Interaction Viewpoint</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('sds-qp_inter.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Interaction Viewpoint</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="sds-qp_struct.html">Structure Viewpoint</a></span><span class="next_button"><a class="el" href="sds-qp_state.html">State Dynamics Viewpoint</a></span> </p><div style="clear:both"></div> <p>The <b>Interaction Design Viewpoint</b> provides an analysis of interactions within QP Framework elements. This design viewpoint frames the following concerns:</p><ul>
<li>behavior of the system under various scenarios of use</li>
<li>interactions in terms of events exchanged among Active Objects</li>
<li>required sequences of operations</li>
<li>control flow</li>
<li>concurrency and parallelism</li>
<li>resource management</li>
</ul>
<h1><a class="anchor" id="sds-qp_inter-beh"></a>
Behavior View</h1>
<p><a id="a136_SDS_5FQA_5FSTART" name="a136_SDS_5FQA_5FSTART"></a> </p>
<h2><a class="anchor" id="SDS_QA_START"></a>
SDS_QA_START</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SDS_QA_START</b>: <em>QA Application startup sequence</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Model Kinds</b><br  />
</p>
<p class="intertd">The QA Application startup sequence is illustrated with two kinds of models:</p><ul>
<li>the UML sequence diagram shown in <a class="el" href="#sds-qp_fig-start">Figure SDS-START</a> (<em>dynamic view</em>)</li>
<li>the pseudocode shown in <a class="el" href="#sds-qp_lst-start">Listing SDS-START</a> (<em>static view</em>)</li>
</ul>
<p class="intertd"><a class="anchor" id="sds-qp_fig-start"></a></p><div class="image">
<object type="image/svg+xml" data="sds-qp_start.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SDS-START: QP Application startup sequence.</em></center></div><p class="intertd"><a class="anchor" id="sds-qp_lst-start"></a>  </p><div class="fragment"><div class="line">[0]  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">[1]      QF_init();  <span class="comment">// initialize the QF Active Object framework</span></div>
<div class="line">[2]      BSP_init(); <span class="comment">// initialize the Board Support Package</span></div>
<div class="line"> </div>
<div class="line">[3]      <span class="comment">// initialize publish-subscribe...</span></div>
<div class="line">         <span class="keyword">static</span> <a class="code hl_struct" href="struct_q_subscr_list.html">QSubscrList</a> subscrSto[MAX_PUB_SIG];</div>
<div class="line">         QActive_psInit(subscrSto, <a class="code hl_define" href="qp_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(subscrSto));</div>
<div class="line"> </div>
<div class="line">[4]      <span class="comment">// initialize event pools...</span></div>
<div class="line">         <span class="keyword">static</span> <a class="code hl_define" href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a>(SmallEvt) smlPoolSto[10];</div>
<div class="line">         QF_poolInit(smlPoolSto, <span class="keyword">sizeof</span>(smlPoolSto), <span class="keyword">sizeof</span>(smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">         <span class="keyword">static</span> <a class="code hl_define" href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a>(MediumEvt) medPoolSto[5];</div>
<div class="line">         QF_poolInit(medPoolSto, <span class="keyword">sizeof</span>(medPoolSto), <span class="keyword">sizeof</span>(medPoolSto[0]));</div>
<div class="line">         . . .</div>
<div class="line"> </div>
<div class="line">[5]      <span class="comment">// instantiate and start Active Objects...</span></div>
<div class="line">         ActiveA_ctor();</div>
<div class="line">         <span class="keyword">static</span> <a class="code hl_class" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> *aoA_QueueSto[5];</div>
<div class="line">         QActive_start(AO_activeA,</div>
<div class="line">             2U,                  <span class="comment">// QP priority of the AO</span></div>
<div class="line">             aoA_QueueSto,        <span class="comment">// event queue storage</span></div>
<div class="line">             <a class="code hl_define" href="qp_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(aoA_QueueSto), <span class="comment">// queue length [events]</span></div>
<div class="line">             (<span class="keywordtype">void</span> *)0, 0U,       <span class="comment">// no stack storage</span></div>
<div class="line">             (<span class="keywordtype">void</span> *)0);          <span class="comment">// no initialization param</span></div>
<div class="line"> </div>
<div class="line">         ActiveB_ctor();</div>
<div class="line">         <span class="keyword">static</span> <a class="code hl_class" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> *aoB_QueueSto[3];</div>
<div class="line">         QActive_start(AO_activeB,</div>
<div class="line">             5U,                  <span class="comment">// QP priority of the AO</span></div>
<div class="line">             aoB_QueueSto,        <span class="comment">// event queue storage</span></div>
<div class="line">             <a class="code hl_define" href="qp_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(aoB_QueueSto), <span class="comment">// queue length [events]</span></div>
<div class="line">             (<span class="keywordtype">void</span> *)0, 0U,       <span class="comment">// no stack storage</span></div>
<div class="line">             (<span class="keywordtype">void</span> *)0);          <span class="comment">// no initialization param</span></div>
<div class="line">         . . .</div>
<div class="line"> </div>
<div class="line">[6]      <span class="comment">// transfer control to QF framework to run the Active Objects</span></div>
<div class="line">         <span class="keywordflow">return</span> QF_run();</div>
<div class="line">     }</div>
<div class="ttc" id="aqmpool_8h_html_ab0fe475154021674f904c52e61e78841"><div class="ttname"><a href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a></div><div class="ttdeci">#define QF_MPOOL_EL(evType_)</div><div class="ttdoc">Memory pool element to allocate correctly aligned storage for QMPool class.</div><div class="ttdef"><b>Definition</b> <a href="qmpool_8h_source.html#l00040">qmpool.h:40</a></div></div>
<div class="ttc" id="aqp_8h_html_ad58d2c6dc25f8f0f764eb69faa79eee2"><div class="ttname"><a href="qp_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a></div><div class="ttdeci">#define Q_DIM(array_)</div><div class="ttdef"><b>Definition</b> <a href="qp_8h_source.html#l00098">qp.h:98</a></div></div>
<div class="ttc" id="astruct_q_evt_html"><div class="ttname"><a href="struct_q_evt.html">QEvt</a></div><div class="ttdoc">Event class.</div><div class="ttdef"><b>Definition</b> <a href="qp_8h_source.html#l00115">qp.h:115</a></div></div>
<div class="ttc" id="astruct_q_subscr_list_html"><div class="ttname"><a href="struct_q_subscr_list.html">QSubscrList</a></div><div class="ttdoc">Subscriber List (for publish-subscribe)</div><div class="ttdef"><b>Definition</b> <a href="qp_8h_source.html#l00498">qp.h:498</a></div></div>
</div><!-- fragment --> <div class="caption"><center><em>Listing SDS-START: QP Application startup sequence.</em></center></div><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">The following descriptions pertain to both <a class="el" href="#sds-qp_fig-start">Figure SDS-START</a> and <a class="el" href="#sds-qp_lst-start">Listing SDS-START</a> because the steps are labeled consistently in these two model kinds.</p>
<p class="intertd"><code>[0]</code> The QP Application startup sequence occurs in the <code>main()</code> function.</p>
<p class="intertd"><code>[1]</code> The Active Object framework layer gets initialized, which also performs initialization of the real-time kernel.</p>
<p class="intertd"><code>[2]</code> The Board Support Package (BSP) initialization sets up the hardware, software tracing (if used), etc.</p>
<p class="endtd"><code>[3]</code> If this QP Application uses <a class="el" href="srs-qp_edm.html#srs-qp_edm-ps">publish-subscribe</a>, it is initialized with a call to <a class="el" href="struct_q_active.html#aeeb00d37acac676bd6652bf59dc6c2b8">QActive_psInit()</a>. </p><dl class="section note"><dt>Note</dt><dd>The QP Application must provide the memory for the subscriber-lists (<code>subscrSto</code>), which is allocated statically in this case.</dd></dl>
<p><code>[4]</code> The QP Application initializes all event pools that it is using by repeated calls to <a class="el" href="class_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit()</a> </p><dl class="section note"><dt>Note</dt><dd>The QP Application must provide the memory for each of the initialized event pools (e.g., <code>medPoolSto</code>), which is allocated statically in this case.</dd></dl>
<p><code>[5]</code> The QP Application instantiates (by calling the constructor) and starts all Active Objects by calling <a class="el" href="struct_q_active.html#ae400eefb2c5d0a186f10864d60833751">QActive_start()</a>. Each Active Objects is assigned <a class="el" href="srs-qp_ao.html#srs-qp_ao-prio">unique priorities</a>, and provided with event-queue buffers and the stacks (if required). Also, this step involves executing the top-most initial transition in the Active Object (<a class="el" href="#sds-qp_fig-start">Figure SDS-START [5B]</a>). Additionally, this step triggers the top-most initial transition in the Active Object's state machine, which might involve some interaction with the BSP to initialize the hardware controlled by this Active Object (<a class="el" href="#sds-qp_fig-start">Figure SDS-START [5C]</a>). </p><dl class="section note"><dt>Note</dt><dd>The QP Application must provide the event-queue buffer (e.g., <code>aoA_QueueSto</code>) and the stack (if required by the underlying kernel) for each started Active Object.</dd></dl>
<p><code>[6]</code> The QP Application transfers control to QF Active Object Framework by calling <a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a>. <a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> begins by calling the <a class="el" href="class_q_f.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup()</a> callback to configure and enable <b>interrupts</b> (<a class="el" href="#sds-qp_fig-start">Figure SDS-START [6A]</a>), as the system is only now ready to receive them. After this, <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> Framework starts execution of Active Objects (<a class="el" href="#sds-qp_fig-start">Figure SDS-START [6B]</a>), which typically involves transferring control to the underlying real-time kernel. </p><dl class="section note"><dt>Note</dt><dd>In deeply embedded applications <a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> does not return. In case QP runs on top of a General-Purpose OS (e.g., POSIX), <a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> might return to the OS. The behavior of <a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> depends on the QP Port (see <a class="el" href="sds-qp_ifc.html">QP OSAL</a>).</dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_res.html#SAS_QP_MEM">SAS_QP_MEM</a>: <em>General memory allocation policy</em></li>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="struct_q_active.html#aeeb00d37acac676bd6652bf59dc6c2b8">QActive::QActive_psInit()</a>: <em>Publish event to all subscribers of a given signal <code>e-&gt;sig</code></em></li>
<li><a class="el" href="class_q_f.html#adac7eccb860d910c4e446d3143798bba">QF::QF_init()</a>: <em><a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> initialization</em></li>
<li><a class="el" href="class_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF::QF_run()</a>: <em>Transfers control to <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> to run the application</em></li>
<li><a class="el" href="class_q_f.html#a189a6d2ece787717c81fbf51fd180732">QF::QF_onStartup()</a>: <em>Startup <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> callback</em></li>
<li><a class="el" href="class_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF::QF_poolInit()</a>: <em>Event pool initialization for dynamic allocation of events</em> </li>
</ul>
</td></tr>
</table>
<h1><a class="anchor" id="sds-qp_inter-evt"></a>
Event Exchange View</h1>
<p><a id="a137_SDS_5FQP_5FPOST" name="a137_SDS_5FQP_5FPOST"></a> </p>
<h2><a class="anchor" id="SDS_QP_POST"></a>
SDS_QP_POST</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SDS_QP_POST</b>: <em>QP event posting sequence</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Model Kinds</b><br  />
</p>
<p class="intertd">Event posting to Active Objects is illustrated with UML sequence diagrams shown in <a class="el" href="#sds-qp_fig-post1">Figure SDS-POST1</a> and <a class="el" href="#sds-qp_fig-post2">Figure SDS-POST2</a> (<em>dynamic views</em>). The views are explained in the labeled descriptions following the sequence diagrams. The chosen scenarios pertain to mutable events dynamically allocated from event pools. Also the shown order of processing corresponds to a <em>preemptive</em> scheduler.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Scenario: Event posting from ISR to Active Object</b><br  />
</p>
<p class="intertd"><a class="anchor" id="sds-qp_fig-post1"></a></p><div class="image">
<object type="image/svg+xml" data="sds-qp_post1.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SDS-POST1: Posting event form ISR to an Active Object.</em></center></div><p class="intertd"><code>[1]</code> Event posting begins with incrementing the reference counter of the event (for mutable events dynamically allocated from event pools), which happens within a critical section.</p>
<p class="intertd"><code>[2]</code> The event is posted to the event queue of the recipient Active Object. The default behavior of the queue is to assert internally that the queue does not overflow and can accept the event (this is part of the event delivery guarantee).</p>
<p class="intertd"><code>[2A]</code> Assuming that the recipient Active Object didn't have events before, adding an event to its queue makes the Active Object ready to run. However, the Active Object is not assigned the CPU just yet because the ISR has a higher priority and continues to completion. (NOTE: the same behavior would occur if the event was posted from an Active Object of a higher priority than the recipient.)</p>
<p class="intertd"><code>[3]</code> Only after the ISR completes, the received event is dispatched to the internal state machine of the recipient Active Object. The virtual <code>dispatch()</code> function runs-to-completion (RTC) in the thread context of the recipient Active Object.</p>
<p class="intertd"><code>[4]</code> After the RTC step, the event is garbage-collected, which decrements the reference counter (for a mutable dynamic event). The event is recycled back to the original event pool only when the reference count drops to zero.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Scenario: Event posting from low-priority to high-priority Active Object</b><br  />
</p>
<p class="intertd"><a class="anchor" id="sds-qp_fig-post2"></a></p><div class="image">
<object type="image/svg+xml" data="sds-qp_post2.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SDS-POST2: Posting event form a lower-priority Active Object to higher-priority Active Object (preemptive scheduler).</em></center></div><p class="intertd"><code>[1]</code> As before in <a class="el" href="#sds-qp_fig-post1">Figure SDS-POST1</a>, event posting begins with incrementing the reference counter of the event (for mutable events dynamically allocated from event pools), which happens within a critical section.</p>
<p class="intertd"><code>[2]</code> As before, the event is posted to the event queue of the recipient Active Object.</p>
<p class="intertd"><code>[2A]</code> However, assuming that the system executes under a <em>preemptive</em>, priority-based scheduler, the recipient Active Object immediately preempts the sender Active Object. This happens because the recipient has a higher priority than the sender and a preemptive scheduler must always give control to the highest-priority Active Object ready to run.</p>
<p class="intertd"><code>[3]</code> The recipient Active Object dispatches the event to its internal state machine.</p>
<p class="intertd"><code>[4]</code> The recipient Active Object calls the garbage-collector to decrement the reference count and recycles the event back to the original event pool.</p>
<p class="intertd"><code>[5]</code> The CPU is assigned back to the preempted sender Active Object. The sender completes its RTC step.</p>
<dl class="section note"><dt>Note</dt><dd>The sender Active Object should NOT access the event after posing because it might be recycled by that time, as illustrated in this scenario. Please see also dynamic event life-cycle in <a class="el" href="srs-qp_emm.html#srs-qp_fig-evt-life">Figure SRS-EVT-LIFE</a>.</dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a138_SDS_5FQP_5FPUB" name="a138_SDS_5FQP_5FPUB"></a> </p>
<h2><a class="anchor" id="SDS_QP_PUB"></a>
SDS_QP_PUB</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SDS_QP_PUB</b>: <em>QP event publishing sequence</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Model Kinds</b><br  />
</p>
<p class="intertd">Event publishing to Active Objects is illustrated with UML sequence diagrams shown in <a class="el" href="#sds-qp_fig-pub1">Figure SDS-PUB1</a> and <a class="el" href="#sds-qp_fig-pub2">Figure SDS-PUB2</a> (<em>dynamic view</em>). The view is explained in the labeled descriptions following the sequence diagram. The chosen scenarios pertain to mutable events dynamically allocated from event pools. Also the shown order of processing corresponds to a <em>preemptive</em> scheduler.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Scenario: Event publishing with scheduler locking</b><br  />
</p>
<p class="intertd"><a class="anchor" id="sds-qp_fig-pub1"></a></p><div class="image">
<object type="image/svg+xml" data="sds-qp_pub1.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SDS-PUB1: Publishing event form a medium-priority Active Object (preemptive scheduler).</em></center></div><p class="intertd"><code>[1]</code> Event publishing begins with incrementing the reference counter of the event (for mutable events dynamically allocated from event pools), which happens within a critical section.</p>
<p class="intertd"><code>[2]</code> Next, the publish operation determines the highest-priority subscriber and selectively locks the scheduler up to that priority. (NOTE: selective scheduler locking is supported by modern real-time kernels. Older kernels support only indiscriminate, global scheduler locking).</p>
<p class="intertd"><code>[3]</code> Event is posted to the highest-priority subscriber Active Object, which increments the reference counter of the event (per <a class="el" href="#SDS_QP_POST">SDS_QP_POST</a>).</p>
<p class="intertd"><code>[3A]</code> Even if the priority of that subscriber is higher than the sender, preemption does not happen because of the scheduler lock.</p>
<p class="intertd"><code>[4]</code> Event is posted to the medium-priority subscriber Active Objects, which increments the reference counter of the event (per <a class="el" href="#SDS_QP_POST">SDS_QP_POST</a>).</p>
<p class="intertd"><code>[5]</code> Event is posted to the low-priority subscriber Active Objects, which increments the reference counter of the event (per <a class="el" href="#SDS_QP_POST">SDS_QP_POST</a>).</p>
<p class="intertd"><code>[4A-5A]</code> The events are only posted, but the recipients Active Objects don't run yet.</p>
<p class="intertd"><code>[6]</code> The publish operation unlocks the scheduler to the previous level before the publishing.</p>
<p class="intertd"><code>[7]</code> The highest-priority recipient Active Object immediately preempts the lower-priority publisher and dispatches the published event to its state machine.</p>
<p class="intertd"><code>[8]</code> During the processing, the highest-priority Active Object posts another event <code>e1</code> to <code>ActiveObjB</code>.</p>
<p class="intertd"><code>[8A]</code> The posted event <code>e1</code> is only enqueued, but is not processed.</p>
<p class="intertd"><code>[9]</code> The highest-priority Active Object continues and garbage-collects the published event. This only decrements its reference counter, but does not recycle the published event.</p>
<p class="intertd"><code>[10]</code> The event publisher garbage-collects the original event. This decrements the reference counter incremented in step <code>[1]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The garbage-collect step <code>[10]</code> prevents event leak in case there are <b>no subscribers</b> to that event.</dd></dl>
<p><code>[11]</code> <code>ActiveObjB</code> dispatches the published event to its state machine.</p>
<p class="intertd"><code>[12]</code> The event publisher garbage-collects published event. This decrements the reference counter, but does not recycle the event yet.</p>
<p class="intertd"><code>[13]</code> <code>ActiveObjB</code> dispatches the posted event <code>e1</code> to its state machine.</p>
<dl class="section remark"><dt>Remarks</dt><dd><code>ActiveObjB</code> processes events in the expected order (based on cause and effect): published event <code>e</code> followed by posted event <code>e1</code> (caused by the published event <code>e</code>).</dd></dl>
<p><code>[14]</code> <code>ActiveObjB</code> garbage-collects the posted event <code>e1</code>, which decrements its reference counter and recycles the event.</p>
<p class="intertd"><code>[15]</code> The lowest-priority <code>ActiveObjA</code> dispatches the published event to its state machine.</p>
<p class="intertd"><code>[16]</code> The lowest-priority <code>ActiveObjA</code> garbage-collects the original event, which decrements its reference counter. This time, the counter drops to zero, so the event is finally recycled to its original event pool.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Scenario: Event publishing WITHOUT scheduler locking</b><br  />
</p>
<p class="intertd"><a class="anchor" id="sds-qp_fig-pub2"></a></p><div class="image">
<object type="image/svg+xml" data="sds-qp_pub2.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SDS-PUB2: Publishing event WITHOUT scheduler locking (preemptive scheduler).</em></center></div><p class="intertd"><code>[1]</code> As before, event publishing begins with incrementing the reference counter of the event (for mutable events dynamically allocated from event pools), which happens within a critical section.</p>
<p class="intertd"><code>[2]</code> The publish operation determines the highest-priority subscriber and posts the event to that Active Object. This increments the reference counter of the event (per <a class="el" href="#SDS_QP_POST">SDS_QP_POST</a>).</p>
<p class="intertd"><code>[3]</code> However, this time the scheduler is NOT locked, so the highest-priority Active Object immediately preempts the lower-priority publisher.</p>
<p class="intertd"><code>[4]</code> During the processing, the higest-priority Active Object posts another event <code>e1</code> to <code>ActiveObjB</code>.</p>
<p class="intertd"><code>[4A]</code> The posted event <code>e1</code> is only enqueued, but is not processed.</p>
<p class="intertd"><code>[5]</code> The highest-priority Active Object continues and garbage-collects the published event. This only decrements its reference counter, but does not recycle the published event because its reference counter has been incremented in step <code>[1]</code></p>
<p class="intertd"><code>[6]</code> The preemptive scheduler resumes the preempted publisher, which posts the original event to <code>ActiveObjB</code>.</p>
<dl class="section note"><dt>Note</dt><dd>At this point, the medium-priority <code>ActiveObjB</code> has two events, which are enqueued in the following order: <code>e1</code> followed by <code>e</code>. This is an <b>unexpected</b> order because event <code>e1</code> is caused by event <code>e</code>, yet it precedes event <code>e</code>. This unexpected re-ordering of events is the result of NOT locking the scheduler.</dd></dl>
<p><code>[6A]</code> The posted event is only enqueued, but is not processed.</p>
<p class="intertd"><code>[7]</code> The preemptive scheduler posts the original event to <code>ActiveObjC</code>.</p>
<p class="intertd"><code>[7A]</code> The posted event is only enqueued, but is not processed.</p>
<p class="intertd"><code>[8]</code> The event publisher garbage-collects the original event. This decrements the reference counter incremented in step <code>[1]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The garbage-collect step <code>[8]</code> prevents event leak in case there are <b>no subscribers</b> to that event.</dd></dl>
<p><code>[9]</code> The medium-priority <code>ActiveObjB</code> dispatches the event <code>e1</code> to its internal state machine.</p>
<p class="intertd"><code>[10]</code> The medium-priority <code>ActiveObjB</code> garbage-collects event <code>e1</code>, which causes recycling of that event.</p>
<p class="intertd"><code>[11]</code> The medium-priority <code>ActiveObjB</code> dispatches the event <code>e</code> to its internal state machine.</p>
<p class="intertd"><code>[12]</code> The medium-priority <code>ActiveObjB</code> garbage-collects published event <code>e</code>, which decrements its reference counter but does not recycle the event yet.</p>
<p class="intertd"><code>[13]</code> The lowest-priority <code>ActiveObjA</code> dispatches the published event <code>e</code> to its internal state machine.</p>
<p class="intertd"><code>[14]</code> The lowest-priority <code>ActiveObjA</code> garbage-collects the published event <code>e</code>, which is no longer referenced, so it is recycled.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Even without scheduler locking, the event publishing performs event multicasting without event leaks. However, without scheduler locking event publishing might end up with an unexpected re-ordering of events, as illustrated for the medium-priority <code>ActiveObjB</code> in this scenario.</dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<div style="clear:both"></div><p> <span class="prev_button"><a class="el" href="sds-qp_struct.html">Structure Viewpoint</a></span><span class="next_button"><a class="el" href="sds-qp_state.html">State Dynamics Viewpoint</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="sds-qp.html">Software Design Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

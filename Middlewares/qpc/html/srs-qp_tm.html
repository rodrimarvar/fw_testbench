<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Time Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_tm.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Time Management</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_emm.html">Event Memory Management</a></span><span class="next_button"><a class="el" href="srs-qp_qs.html">Software Tracing</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_tm-intro"></a>
Concepts &amp; Definitions</h1>
<p>Time management available in a traditional RTOS includes delaying a calling thread by timed blocking (<code>delay()</code>) or blocking with a timeout on various kernel objects (e.g., semaphores or event flags). These blocking mechanisms are <em>not</em> useful in Active Object-based systems where <a class="el" href="srs-qp_ao.html#srs-qp_ao-block">blocking is not allowed</a>. Instead, to be compatible with the <a class="el" href="srs-qp_ao.html#srs-qp_ao-model">Active Object model of computation</a>, time management must be based on the <em>event-driven paradigm</em> in which every relevant for the system occurrence manifests itself as an event instance.</p>
<h2><a class="anchor" id="srs-qp_tm-te"></a>
Time Events</h2>
<p>An event-driven framework like QP needs an event-driven time management mechanism based on <b>Time Events</b> (sometimes called timers). A Time Event is a UML term and denotes a point in time (at the specified time, the event occurs <a class="el" href="srs-qp.html#srs-qp_ref">[UML 2.5]</a>). A Time Event is said to be <em>armed</em> when it is actively timing out towards the specified time in the future. When the specified time arrives, the Time Event <em>expires</em> and QP Framework directly posts the Time Event to the event queue of the <em>recipient</em> Active Object. An expired Time Event armed originally for one-shot gets automatically <b>disarmed</b>. A Time Event armed for periodic expiration gets automatically <b>re-armed</b> to expire again in the specified time interval in the future. A disarmed Time Event is dormant and must be explicitly armed to time out in the future.</p>
<h2><a class="anchor" id="srs-qp_tm-tick"></a>
System Clock Tick</h2>
<p>Most real-time systems, including traditional RTOSes and Active Object Frameworks like QP, require a periodic time source called the <b>System Clock Tick</b> to keep track of time delays, timeouts, and armed Time Events in case of the event-driven QP Framework. The System Clock Tick must call a special service in the QP Framework to periodically update all armed Time Events.</p>
<p>The System Clock Tick is typically a periodic interrupt (asynchronous with respect to the baseline code execution) that occurs at a predetermined rate, typically between 10Hz and 1000Hz. This rate establishes the basic time units as "clock ticks" and the resolution of Time Events as integer number of "clock ticks". The faster the tick rate, the finer the granularity of "clock ticks" and higher resolution of Time Events, but also the more overhead the time management implies.</p>
<p><a class="anchor" id="srs-qp_fig-te-jit"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_te-jit.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-TE-JIT: Jitter of a periodic Time Event expiring every tick</em></center></div><p>Even though the resolution of Time Events is one "clock tick", it does not mean that the accuracy is also one "clock tick". <a class="el" href="#srs-qp_fig-te-jit">Figure SRS-TE-JIT</a> shows in a somewhat exaggerated manner that the Time Event delivery and eventual handling is always subject to <b>jitter</b>. The main sources of this jitter are the following variable delays:</p>
<p><code>[1]</code> Delay caused by the varying length of processing inside the System Clock Tick ISR</p>
<p><code>[2]</code> Delay caused by the varying length of processing inside the higher-priority Active Objects or other "naked" threads in the system (such processing might also be triggered by the system Clock Tick ISR)</p>
<p><code>[3]</code> Delay caused by the varying length of processing inside the recipient Active Object.</p>
<p>Generally the jitter in Time Event processing gets worse as the priority of the recipient Active Object gets lower. In heavily loaded systems, the jitter might even exceed one "clock tick" period. In particular, a Time Event armed for just one tick might expire almost immediately because the System Clock Tick is <em>asynchronous</em> with respect to Active Object execution. To guarantee at least one "clock tick" timeout, you need to arm a Time Event for two clock ticks. Note too that Time Events are generally not lost due to event queuing. This is in contrast to clock ticks of a traditional RTOS, which can be lost during periods of heavy loading.</p>
<h2><a class="anchor" id="srs-qp_tm-power"></a>
Power Efficiency</h2>
<p>Time management has a big impact on the <b>power efficiency</b> of the system. Specifically the need to periodically service Time Events (or various timeouts in a traditional RTOS kernel) has the unfortunate side effect of constantly interrupting the CPU, which means that the CPU can spend less time in the low-power sleep mode.</p>
<h2><a class="anchor" id="srs-qp_tm-tickless"></a>
"Tickless Mode"</h2>
<p>While a fixed System Clock Tick is very useful, it often interrupts the CPU regardless if real work needs to be done or not. To mitigate that problem, some real-time kernels use the low-power optimization called the "Tickless Mode" (a.k.a. "tick suppression" or "dynamic tick"). In this mode, instead of indiscriminately making the System Clock Tick expire with a fixed period, the kernel adjusts the clock ticks dynamically, as needed. Specifically, after each clock tick the kernel re-calculates the time for the next clock tick and then sets the clock tick interrupt for the earliest timeout it has to wait for. For example, if the shortest timeout the kernel has to attend to is 300 milliseconds into the future, then the clock interrupt will be set for 300 milliseconds.</p>
<p>This approach maximizes the amount of time the CPU can remain asleep, but requires the kernel to perform the additional work to calculate the dynamic tick intervals and to program them into the hardware. This additional bookkeeping adds complexity to the kernel, might be an additional source of jitter and, most importantly, extends the time CPU spends in the high-power active mode and thus eliminates some of the power gains the "Tickless Mode" was supposed to bring.</p>
<p>Also, the "Tickless Mode" requires a more capable hardware timer that must be able of being reprogrammed for every interrupt in a wide dynamic range and also must accurately keep track of the elapsed time to correct for the irregular (dynamic) tick intervals. Still, even with various precautions and corrections, "Tickless Mode" often causes a <b>drift</b> in the timing of the clock tick.</p>
<h2><a class="anchor" id="srs-qp_tm-rates"></a>
Multiple Tick Rates</h2>
<p>For the reasons just described, QP Framework does not support "Tickless Mode". Instead, QP Framework supports <b>multiple clock tick rates</b> as an alternative way of achieving similar goals (to avoid interrupting the CPU at higher rate than necessary.)</p>
<p>Support for multiple tick rates means that each Time Event instance in QP is associated with a particular clock tick rate. For example, TimeEvt0 instance might be associated with rate #0 of only 10Hz, while TimeEvt1 instance might be associated with rate #1 of 1000Hz. The higher tick rate #1 is needed only occasionally (only in certain modes of the system), which means that TimeEvt1 is armed only during these periods and otherwise is disarmed. This provides an opportunity to shut down the high tick rate #1 of 1000Hz when it is not needed, and QP Framework provides a method for finding out when there are no armed Time Events for any given rate. The high tick rate #1 can be re-started again only when some Time Events (like TimeEvt1) get armed again. In an extreme case, a system can shut down all clock tick rates until some external event (typically interrupt) wakes the system up.</p>
<p>"Shutting down" a clock rate might be implemented in various ways. For example, a hardware timer that generates an interrupt at that rate can be disabled. But it is also possible to generate multiple tick rates from one hardware timer. In that case, shutting down a clock rate might mean reprogramming that timer to generate interrupts at a different period. All of this is under control of QP Application.</p>
<p>From the point of view of QP Framework, the support for multiple static clock tick rates is significantly simpler than the "Tickless Mode", and essentially does not increase the complexity of the framework because the same code for the single tick rate can handle other tick rates the same way. Also, multiple static tick rates require much simpler hardware timers, which can be clocked specifically to the desired tick rate and don't need particularly wide dynamic range. For example, 16-bit timers or even 8-bit timers with or without prescalers are completely adequate. Yet the multiple clock rates can deliver similar low-power performance for the system, while keeping QP Framework much simpler and easier to certify than "Tickless" Kernels.</p>
<h1><a class="anchor" id="srs-qp_tm-req"></a>
Requirements</h1>
<p><a id="a61_SRS_5FQP_5FTM_5F00" name="a61_SRS_5FQP_5FTM_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_00"></a>
SRS_QP_TM_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_00</b>: <em>QP Framework shall support Time Events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for Time Events means that QP Framework shall provide a Time Event abstraction that behaves like other <a class="el" href="srs-qp_evt.html">events in %QP</a>, but is additionally equipped with the notion of time passage. The time passage consists of discrete steps (clock ticks). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The basic usage model of the Time Events is as follows. An Active Object allocates and initializes one or more Time Event instances. When the Active Object needs to arrange for a timeout, it arms one of its time events to expire either just once (one-shot) or periodically. Each Time Event times out independently from the others, so a QP Application can make multiple parallel timeout requests (from the same or different Active Objects). When QP Framework service associated with the armed Time Events detects that the appropriate moment has arrived, it inserts the expiring Time Event instance directly into the recipient's event queue using the default FIFO policy with event delivery guarantee (<a class="el" href="srs-qp_edm.html#SRS_QP_EDM_00">SRS_QP_EDM_00</a>). The recipient Active Object then processes the Time Event instance just like any other event. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em></li>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em><ul>
<li>SAS_QP_FUSA_02: <em><u>Error detecting codes</u> mechanisms to protect critical variables.</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QA_START">SDS_QA_START</a>: <em>QA Application startup sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_POST">SDS_QP_POST</a>: <em>QP event posting sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_PUB">SDS_QP_PUB</a>: <em>QP event publishing sequence</em></li>
</ul>
</li>
<li>SVP_QP_inst: <em>QP/C Framework installation files.</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a62_SRS_5FQP_5FTM_5F10" name="a62_SRS_5FQP_5FTM_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_10"></a>
SRS_QP_TM_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_10</b>: <em>QP Framework shall support up to 15 clock tick rates.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for multiple clock tick rates means that QP Framework shall provide that many different ways of grouping Time Events and associating them with a given clock tick rate. The maximum number of clock tick rates supported by QP Framework shall be compile-time configurable with the maximum of 15. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a63_SRS_5FQP_5FTM_5F11" name="a63_SRS_5FQP_5FTM_5F11"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_11"></a>
SRS_QP_TM_11</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_11</b>: <em>For every clock rate QP Framework shall provide a clock-tick processing operation that QP Application must call periodically to service the armed Time Events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The clock-tick processing operation shall update all armed Time Events associated with a given tick rate. The clock-tick processing operation must be callable from the interrupt level and also from the thread level (e.g., from an Active Object). Also, clock-tick processing operations for different tick rates must be allowed to preempt each other (e.g., higher clock tick rates might be serviced from interrupts while others from threads). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Framework can provide the clock-tick processing operation parameterized by the tick rate. For each tick rate, QP Application must then invoke the corresponding clock-tick processing operation at the right period either from a time-tick ISR or from the thread level. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a64_SRS_5FQP_5FTM_5F20" name="a64_SRS_5FQP_5FTM_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_20"></a>
SRS_QP_TM_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_20</b>: <em>QP Framework shall provide Time Event initialization.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The association between a Time Event and the event signal, recipient Active Object, and the tick rate shall be made only during initialization (e.g., via a constructor) and shall not be changed later during the lifetime of the Time Event. </p>
</td></tr>
</table>
<p><a id="a65_SRS_5FQP_5FTM_5F21" name="a65_SRS_5FQP_5FTM_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_21"></a>
SRS_QP_TM_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_21</b>: <em>QP Framework shall allow a Time Event to be armed both for one-shot and periodic expiry.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">A Time Event shall provide a service to arm it to expire in a specified number of clock ticks of the associated clock tick rate (one-shot expiration). Additionally, the service shall allow specifying an interval for automatic re-arming the Time Event (periodic expiration). The special value zero (interval == 0) shall denote no periodic re-arming.</p>
<p class="intertd">Arming an already armed Time Event shall be considered as a programming error and the QP Framework shall enter a safe state.</p>
<p class="endtd">When the Timeout Expires, it gets directly posted (using the default FIFO policy with event delivery guarantee) into the event queue of the recipient Active Object. After posting, a one-shot time event gets automatically disarmed while a periodic time event (interval != 0) is automatically re-armed. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a66_SRS_5FQP_5FTM_5F22" name="a66_SRS_5FQP_5FTM_5F22"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_22"></a>
SRS_QP_TM_22</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_22</b>: <em>QP Framework shall allow a Time Event to be explicitly disarmed.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">A Time Event shall provide a service to disarm it. This service shall be available for Time Events armed for one-shot or periodic expiration. Disarming an already disarmed Time Event is fine and not considered an error. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">Due to the asynchronous nature of System Clock Tick, an Active Object sometimes cannot know whether a one-shot Time Event was automatically disarmed. Therefore the disarm operation shall return the status of the Time Event. The return of 'true' shall mean that the Time Event was still armed. The return of 'false' means that the Time Event was not truly disarmed because it has already expired. The 'false' return is only possible for one-shot Time Events that have been automatically disarmed upon expiration. In this case the 'false' return means that the Time Event has already been posted and should be expected in the recipient Active Object's event queue. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a67_SRS_5FQP_5FTM_5F23" name="a67_SRS_5FQP_5FTM_5F23"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_23"></a>
SRS_QP_TM_23</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_23</b>: <em>QP Framework shall allow a Time Event to be rearmed.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">A Time Event shall provide a service to rearm it to expire in a specified number of clock ticks (of the associated tick rate). This service shall be available for Time Events armed for one-shot or periodic expiration. Rearming a Time Event that is disarmed is fine and not considered an error. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="intertd">The rearm service can be used to adjust the current period of a periodic time event or to prevent a one-shot time event from expiring (e.g., a watchdog Time Event). Rearming a periodic timer leaves the interval unchanged and is a convenient method to adjust the phasing of a periodic time event.</p>
<p class="endtd">Due to the asynchronous nature of System Clock Tick, an Active Object sometimes cannot know whether a one-shot Time Event was automatically rearmed. Therefore the rearm operation shall return the status of the Time Event. Return 'true' shall mean that the Time Event was running as it was re-armed. The 'false' return means that the Time Event was not truly rearmed because it has already expired. The 'false' return is only possible for one-shot Time Events that have been automatically disarmed upon expiration. In this case the 'false' return means that the Time Event has already been posted and should be expected in the Active Object's event queue. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a68_SRS_5FQP_5FTM_5F30" name="a68_SRS_5FQP_5FTM_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_30"></a>
SRS_QP_TM_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_30</b>: <em>QP Framework shall provide operation to check whether any Time Events are armed for a given tick rate.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The operation shall return 'true' if no Time Events are armed at the given tick rate and 'false' otherwise. Also, due to the asynchronous nature of system clock tick, the operation shall be designed to run inside a critical section thus preventing preemption. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a69_SRS_5FQP_5FTM_5F40" name="a69_SRS_5FQP_5FTM_5F40"></a> </p>
<h2><a class="anchor" id="SRS_QP_TM_40"></a>
SRS_QP_TM_40</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_TM_40</b>: <em>QP Framework shall support low-power sleep modes.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework shall detect the <em>idle condition</em> of the system and provide a mechanism for QP Application to enter the desired sleep mode <b>safely</b>. "Entering a sleep mode safely" means that there should be no race conditions and situations, where the system would enter a sleep mode with some events present in the Active Object event queues and thus requiring processing. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_emm.html">Event Memory Management</a></span><span class="next_button"><a class="el" href="srs-qp_qs.html">Software Tracing</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

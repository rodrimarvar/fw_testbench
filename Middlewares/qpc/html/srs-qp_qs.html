<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Software Tracing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_qs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Software Tracing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_tm.html">Time Management</a></span><span class="next_button"><a class="el" href="srs-qp_qv.html">Non-Preemptive Kernel</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_qs-intro"></a>
Concepts &amp; Definitions</h1>
<p>In any real-life project, getting the code written, compiled, and successfully linked is only the first step. The system still needs to be tested, validated, and tuned for best performance and resource consumption. A single-step debugger is frequently not helpful because it stops the system and exactly hinders seeing live interactions within the application. Clogging up high-performance code with <code>printf()</code> statements is usually too intrusive and simply unworkable in most embedded systems. So the questions are: How can you monitor the behavior of a running real-time system without degrading the system itself? How can you discover and document elusive, intermittent bugs that are caused by subtle interactions among concurrent components? How do you design and execute repeatable unit and integration tests of your system? How do you ensure that a system runs reliably for long periods of time and gets top processor performance? Techniques based on <a class="el" href="#srs-qp_qs-set">Software Tracing</a> can answer many of these questions.</p>
<h2><a class="anchor" id="srs-qp_qs-set"></a>
What is Software Tracing?</h2>
<p><b>Software Tracing</b> is a method for obtaining diagnostic information in a <em>live</em> environment without the need to stop or even significantly slow down the application to get the system feedback. Software Tracing always involves some form of a target system <b>instrumentation</b> to log the relevant discrete occurrences inside the target for subsequent retrieval from the target to the host computer and analysis. An example of Software Tracing is sprinkling the code with <code>printf()</code> statements, which are a crude tracing instrumentation in this case. Of course, a professional Software Tracing system can be far less intrusive and more powerful than the primitive <code>printf()</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>In the context of safety certification, the Software Tracing system described in this part of the Software Requirement Specification plays a <b>critical role</b>. It provides the backbone of testing, verification, and validation strategies for both QP Framework and QP Applications.</dd></dl>
<p>The <a class="el" href="#srs-qp_fig-qs-set">Figure SRS-QS-SET</a> below shows a typical setup for Software Tracing, which always consists of two components:</p>
<ol type="1">
<li><b>Target-resident component</b> for generating and sending the trace data. This component might also <em>receive</em> commands from the host to execute on the target; and</li>
<li><b>Host-resident component</b> to receive, parse, validate, visualize, and analyze the data.</li>
</ol>
<p><a class="anchor" id="srs-qp_fig-qs-set"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qs-set.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QS-SET: Typical setup for Software Tracing.</em></center></div><dl class="section remark"><dt>Remarks</dt><dd>The discrete occurrences logged by a Software Tracing system are sometimes referred to as "events". However, in the context of an event-driven framework like QP, these occurrences will be called <b>trace records</b>, to avoid confusing them with the <a class="el" href="srs-qp_evt.html">application-level events</a>.</dd></dl>
<h2><a class="anchor" id="srs-qp_qs-ao"></a>
Software Tracing &amp; Active Objects</h2>
<p>Software Tracing is particularly effective and powerful in combination with the event-driven <a class="el" href="srs-qp_ao.html#srs-qp_ao-model">Active Object model of computation</a>. Due to the <a class="el" href="srs-qp_ao.html#srs-qp_ao-inv">inversion of control</a>, a running application built of Active Objects is a highly structured affair where all important system interactions funnel through the underlying event-driven framework. This arrangement offers a unique opportunity for applying Software Tracing in a framework like QP.</p>
<p><a class="anchor" id="srs-qp_fig-qs-fun"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qs-fun.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QS-FUN: Software tracing in QP Framework</em></center></div><p>Tracing instrumentation inside just the QP Framework provides an unprecedented wealth of information about the running system, far more detailed and comprehensive than any traditional RTOS can provide (because RTOS is <em>not</em> based on control inversion.) The Software Trace data from the framework alone can produce:</p>
<p><code>[1]</code> detailed state machine activity in all Active Objects and other state machines in the system.</p>
<p><code>[2]</code> detailed information about event posting/publishing, queuing, recycling. This also includes complete, time-stamped sequence diagrams.</p>
<p><code>[3]</code> detailed information about real-time kernel activity, like: kernel objects, context switches, scheduler, etc.</p>
<p><code>[4]</code> custom application-specific trace records</p>
<p>This ability can form the foundation of the whole <b>testing</b> strategy for QP Application. In addition, individual Active Objects are natural entities for unit testing, which you can perform simply by injecting events into the Active Objects and collecting the generated execution trace. Software Tracing at the framework level makes all this comprehensive information available to the application developers, even with <em>no instrumentation</em> added to the application-level code.</p>
<h2><a class="anchor" id="srs-qp_qs-qpspy"></a>
QP/Spy Software Tracing System</h2>
<p>QP/Spy is a Software Tracing and testing system specifically designed for and embedded in the QP Framework. As shown in <a class="el" href="#srs-qp_fig-qs-str">Figure SRS-QS-STR</a>, QP/Spy consists of the following components:</p>
<ol type="1">
<li>Target-resident component called <b>QS</b>. This component is part of QP Framework and is the main subject of this Software Requirements Specification. The QS target-resident component consists of the QS-TX RAM buffer, the QS Filters, as well as the <a class="el" href="#srs-qp_qs-pre">instrumentation embedded in the %QP Framework</a>. Additionally, the QS target-resident component contains the <a class="el" href="#srs-qp_qs-rx">receive-channel (QS-RX)</a> with its own RAM buffer, which can receive data from the QSPY host component.</li>
<li>Host-resident component called <b>QSPY</b>. This component is not part of QP Framework and is described in the <a href="https://www.state-machine.com/products/qtools" target="_blank" rel="noopener">QTools collection&uarr;</a>.</li>
</ol>
<p><a class="anchor" id="srs-qp_fig-qs-str"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qs-str.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QS-STR: Structure of the QP/Spy Software Tracing system.</em></center></div><dl class="section note"><dt>Note</dt><dd>The QS tracing instrumentation is <b>inactive</b> by default. It becomes active only when explicitly enabled (by defining a special macro). This means that the QS instrumentation can be safely left in the code for future development, testing, and maintenance.</dd></dl>
<h2><a class="anchor" id="srs-qp_qs-proto"></a>
Data Protocol</h2>
<p>The QS target-resident component inserts trace records into the QS-TX RAM buffer using a <b>binary</b> data protocol. The QP/Spy protocol must be lightweight, but must support clearly delimited <b>frames</b>, as well as provisions to check data <b>continuity</b> and <b>integrity</b> of the frames. These features are necessary to allow flexible removal of data from the RAM buffer in any chunks typically not aligned with the frame boundaries. Finally, the data transmitted from the target with the QS data protocol must also allow the host to <b>instantaneously re-synchronize</b> after any buffering or transmission error to minimize loss of useful data.</p>
<h2><a class="anchor" id="srs-qp_qs-filter"></a>
Run-time Filtering</h2>
<p>To minimize the intrusiveness of tracing, the QS target-resident component must perform efficient, selective logging of trace records using as little processing and memory resources of the target as possible. Selective logging means that the tracing system provides user-definable, fine-granularity <b>filters</b> so that the QS target-resident component only collects trace records of interest, and you can filter out as many or as few instrumented trace records as you need.</p>
<h2><a class="anchor" id="srs-qp_qs-pre"></a>
Predefined Trace Records</h2>
<p>QP Framework contains the tracing instrumentation for <b>pre-defined trace records</b>, such as state machine activity (dispatching events, entering/exiting a state, executing transitions, etc.), Active Object activity (allocating events, posting/publishing events, time events, etc.), and more. These QS records have predefined (hard-coded) structure both in the QS target-resident component and in the QSPY host-based application.</p>
<h2><a class="anchor" id="srs-qp_qs-app"></a>
Application-Specific Trace Records</h2>
<p>In addition to the predefined QS records, QP Application can add its own, flexible, <b>application-specific trace records</b>, whose structure is not known in advance to the QSPY host-resident component. Application-specific trace records carry the format information in them.</p>
<h2><a class="anchor" id="srs-qp_qs-dict"></a>
QS Dictionaries</h2>
<p>Every Software Tracing system, just like every single-step debugger, needs the <em>symbolic information</em>, such as the names of various objects, names of functions, and symbolic names of event signals. This is because by the time source code is compiled and loaded into the target, the symbolic information is stripped. Therefore, the symbolic information must be somehow provided to the QSPY host-resident component, so that it can associate the symbolic names with binary addresses and other binary information received from the target and then display the symbolic names in the human-readable trace. Various Software Tracing systems approach this problem differently.</p>
<p>The QS target-resident component provides special <b>dictionary trace records</b> designed expressly for providing the symbolic information about the target code in the trace itself. These "dictionary records" provide mapping between the unique object or function addresses in the target memory and the corresponding symbolic names from the source code. The dictionary trace records are typically generated during the system initialization and this is the only time they are sent to the QSPY host component. Generating the "dictionaries" is the responsibility of the QP Application.</p>
<h2><a class="anchor" id="srs-qp_qs-rx"></a>
QS-RX Receive Channel</h2>
<p>The QS target-resident component can also implement a <em>receive-channel</em> (QS-RX), which allows receiving, parsing and executing commands from the QSPY host application. Such a QS-RX channel can be the backbone for interacting with the target system and implementing such features as <b>unit testing</b> and <b>monitoring</b> of the target system.</p>
<h2><a class="anchor" id="srs-qp_qs-reent"></a>
Reentrancy</h2>
<p>Finally, the QS target-resident tracing component must allow consolidating data from all parts of the system, including concurrently executing Active Objects, "naked" threads (if used), and interrupts. This means that the QS API must be <b>reentrant</b> (i.e., both thread-safe and interrupt-safe).</p>
<h1><a class="anchor" id="srs-qp_qs-req"></a>
Requirements</h1>
<p><a id="a70_SRS_5FQP_5FQS_5F00" name="a70_SRS_5FQP_5FQS_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_00"></a>
SRS_QP_QS_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_00</b>: <em>QP Framework shall support Software Tracing.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for Software Tracing means that QP Framework shall implement the QS target-resident component. This also means that QP Framework shall provide the Software Tracing API for initializing the QS target-resident component, setting up the filters, encoding QS trace records, accessing the QS trace buffers, etc. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a71_SRS_5FQP_5FQS_5F01" name="a71_SRS_5FQP_5FQS_5F01"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_01"></a>
SRS_QP_QS_01</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_01</b>: <em>QS target-resident component shall be inactive by default and activated only when explicitly enabled.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS tracing API shall be inactive by default, meaning it should not produce any executable code. The QS instrumentation shall become activate only when explicitly enabled. This requirement does NOT mean that the QS tracing instrumentation gets removed or changed in the QP Framework or QP Application source code. Instead, this requirement means that the (inactive) QS instrumentation can be safely left in the source code (both QP Framework and QP Application) to help in future development, testing, and maintenance. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The QS API can be implemented as preprocessor macros (in C or C++), which are defined to nothing by default resulting in no code generation by the compiler. Only when a special macro is defined (e.g., <code>Q_SPY</code>), the QS API can be defined such that it actually generates code. That way also avoids contaminating the source code with conditional compilation for every QS API, which could run the risk of inadvertently leaving some QS APIs active (should the developer forget to surround the QS API with conditional compilation). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a72_SRS_5FQP_5FQS_5F10" name="a72_SRS_5FQP_5FQS_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_10"></a>
SRS_QP_QS_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_10</b>: <em>QS target-resident component shall use the binary data protocol.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS target-resident component shall produce tracing data into the RAM buffer encoded by means of a binary protocol. The main feature required from the applied protocol is maintaining clearly delimited <b>frames</b>, each containing one trace record. The protocol "frames" shall contain the following elements:</p><ul>
<li><b>sequence-number</b> to enable checking data continuity (range 0..255, "wrapping around")</li>
<li><b>record-id</b> to identify the type of the trace record (range 0..127)</li>
<li>optional <b>time-stamp</b> data element (configurable length integer of 1, 2, or 4 bytes)</li>
<li>optional <b>data-payload</b> (length 0..n bytes)</li>
<li><b>checksum</b> (range 0..255) to enable checking integrity of the frame </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">This requirement can be met, for example, by a High Level Data Link Control (HDLC) protocol, which is characterized by establishing a very easily identifiable frames in the serial data stream. Any receiver of such a protocol can instantaneously synchronize to the frame boundary by simply finding the Flag byte (typically 0x7E). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a73_SRS_5FQP_5FQS_5F11" name="a73_SRS_5FQP_5FQS_5F11"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_11"></a>
SRS_QP_QS_11</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_11</b>: <em>QS target-resident component shall allow flexible buffering schemes and decoupling trace generation from transmission to the host.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS data protocol is the main enabler for a flexible <em>buffering</em> policy. Specifically, the protocol inserts only complete trace records as clearly delimited "frames" into the RAM buffer, which has two important consequences:</p><ol type="1">
<li>For each trace record the QS transmission protocol maintains both the continuity and the integrity checks (see <a class="el" href="#SRS_QP_QS_10">SRS_QP_QS_10</a>), which means that any data corruption caused by overrunning the old data with the new data can be always reliably detected on the host side. Therefore, the new trace data can be simply inserted into the trace RAM buffer, regardless if it perhaps overwrites the old data that hasn't been removed and sent out yet. The detection of any data corruption can be thus removed from the target system and deferred to the QSPY host component.</li>
<li>The insertion of delimited "frames" in the trace buffers enables <b>decoupling</b> data insertion into the trace buffers from data removal out of the trace buffers. QP Application can remove the trace data in arbitrary chunks, without any consideration for frame boundaries. QP Application can employ any physical data link available in the target for transferring the trace data the host. </li>
</ol>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a74_SRS_5FQP_5FQS_5F20" name="a74_SRS_5FQP_5FQS_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_20"></a>
SRS_QP_QS_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_20</b>: <em>QS target-resident component shall support Global-Filter.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS Global-Filter is based on the <b>record-id</b> associated with each QS trace record (see <a class="el" href="#SRS_QP_QS_10">SRS_QP_QS_10</a>). The Global-Filter shall allow QP Application to disable or enabling each individual record-id or an arbitrary subset of record-ids. For example, QP Application might enable or disable only state-machine-entry records, or all state-machine group of records. This filter works globally for all trace records in the entire system. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a75_SRS_5FQP_5FQS_5F21" name="a75_SRS_5FQP_5FQS_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_21"></a>
SRS_QP_QS_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_21</b>: <em>QS target-resident component shall support Local-Filter.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS Local-Filter is based on the individual <b>object-id</b> associated with various objects in the target memory. The object-ids are small integer numbers in the range 0..127. The object-ids in the range 0..64 are reserved for the Active Objects, where object-id corresponds to the <a class="el" href="srs-qp_ao.html#srs-qp_ao-prio">unique priority</a> of the Active Object. QP Application can associate other remaining object-ids (65..127) with other objects. Then, QP Application can set up the QS Local-Filter to enable only a specific object-id or any subset of object-ids. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The main use case for the Local-Filter is an application where certain objects (e.g., Active Objects) are very "noisy", and would overwhelm the trace. The Local-Filter allows QP Application to silence the "noisy" objects and let the others through. Please note that the Global-Filter cannot achieve such a selection and must be complemented by the Local-Filter. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a76_SRS_5FQP_5FQS_5F30" name="a76_SRS_5FQP_5FQS_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_30"></a>
SRS_QP_QS_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_30</b>: <em>QS target-resident component shall support predefined trace records.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Predefined trace records are trace records with a fixed format known upfront by both the <a class="el" href="class_q_s.html" title="Software tracing instrumentation, target-resident component (QS namespace emulated as a &quot;class&quot; in C)">QS</a> target-resident component and the QSPY host-resident component. Every predefined trace record is uniquely identified by its <b>record-id</b> (see <a class="el" href="#SRS_QP_QS_10">SRS_QP_QS_10</a>), and the record-id range 0..100 is reserved for the predefined records. This one-to-one mapping between record-ids and predefined records allows the QSPY host-resident component to easily recognize and correctly parse all the "pre-defined" records. Most predefined trace records have the timestamp data element (see <a class="el" href="#SRS_QP_QS_10">SRS_QP_QS_10</a>), but some (e.g., dictionary trace records) do not. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">Predefined trace records are used for tracing instrumentation embedded in the QP Framework, such as state machine activity (dispatching events, entering/exiting a state, executing transitions, etc.), Active Object activity (allocating events, posting/publishing events, time events, etc.), and more. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a77_SRS_5FQP_5FQS_5F31" name="a77_SRS_5FQP_5FQS_5F31"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_31"></a>
SRS_QP_QS_31</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_31</b>: <em>QS target-resident component shall support application-specific trace records.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Application-specific trace records have flexible format not known in advance to the QSPY host-resident component. Instead, application-specific trace records carry the format information in them (which makes them somewhat less efficient than predefined trace records). The record-ids of application-specific trace records are in the range 101-127, and are used only for the Local-Filter (see <a class="el" href="#SRS_QP_QS_20">SRS_QP_QS_20</a>). However, the record-ids in this case do not determine any specific format of the application-specific record. In other words, many application-specific trace records can have the same record-id. All application-specific trace records have the timestamp data element (see <a class="el" href="#SRS_QP_QS_10">SRS_QP_QS_10</a>). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">Application-specific trace records are used for tracing instrumentation embedded in the QP Applications. Their flexible format allows the QP Application to add arbitrary information to the software trace. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a78_SRS_5FQP_5FQS_5F40" name="a78_SRS_5FQP_5FQS_5F40"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_40"></a>
SRS_QP_QS_40</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_40</b>: <em>QS target-resident component shall provide symbolic information in the trace by means of dictionary trace records.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The QS target-resident component provides special predefined dictionary trace records designed expressly for providing the symbolic information about the target code in the trace itself. These dictionary records are similar to the symbolic information embedded in the object files for the traditional single-step debugger. QS supports five types of dictionary trace records:</p><ol type="1">
<li>object dictionary</li>
<li>function dictionary</li>
<li>signal dictionary</li>
<li>enumeration dictionary</li>
<li>user dictionary (for the application-specific trace records) </li>
</ol>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a79_SRS_5FQP_5FQS_5F50" name="a79_SRS_5FQP_5FQS_5F50"></a> </p>
<h2><a class="anchor" id="SRS_QP_QS_50"></a>
SRS_QP_QS_50</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QS_50</b>: <em>QS target-resident component shall provide the receive channel to allow interaction between the host and the target.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">A QS-RX channel is required for interacting with the target system and implementing such features as testing, validation, verification, and monitoring of the target system. The QS-RX channel provides the following services:</p><ul>
<li>Remotely reset the Target</li>
<li>Request target information (version, all sizes of objects, build time-stamp)</li>
<li>Execute a user-defined command inside the target with arguments supplied from the QSPY host component</li>
<li>Inject an arbitrary event to the target (dispatch, post or publish)</li>
<li>Changing the Global-Filter" inside the target (see @ref SRS_QP_QS_20)
- Changing the Local-Filter" inside the target (see <a class="el" href="#SRS_QP_QS_21">SRS_QP_QS_21</a>)</li>
<li>Changing the Current-Object inside the target</li>
<li>Peek data inside the target memory</li>
<li>Poke data into the target memory</li>
<li>Fill a specified target memory area with the supplied bit pattern</li>
<li>Execute clock tick inside the target</li>
<li>Execute test setup inside the target</li>
<li>Execute test teardown inside the Target</li>
<li>Store a "Test Probe" inside the target </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_tm.html">Time Management</a></span><span class="next_button"><a class="el" href="srs-qp_qv.html">Non-Preemptive Kernel</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

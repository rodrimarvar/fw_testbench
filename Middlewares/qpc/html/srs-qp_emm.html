<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Event Memory Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_emm.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Event Memory Management</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_edm.html">Event Delivery Mechanisms</a></span><span class="next_button"><a class="el" href="srs-qp_tm.html">Time Management</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_emm-def"></a>
Concepts &amp; Definitions</h1>
<p>In QP Framework, as in any event-driven system, events are frequently passed from producers to consumers. The exchanged event instances can be either <a class="el" href="#srs-qp_emm-imm">immutable</a> or <a class="el" href="#srs-qp_emm-mut">mutable</a>.</p>
<h2><a class="anchor" id="srs-qp_emm-imm"></a>
Immutable Events</h2>
<p><b>Immutable events</b> are event instances that never change at runtime. Such immutable events can be pre-allocated statically (typically and preferably in ROM) and can be <b>shared safely</b> among any number of concurrent entities (Active Objects, ISRs, "naked" threads, etc.) rather than being created and recycled dynamically every time. QP Framework does not need to manage memory for immutable events, but needs to clearly distinguish them from <a class="el" href="#srs-qp_emm-mut">mutable events</a>, precisely to <em>avoid</em> any memory management for them.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Immutability is a desirable property of event instances because exchanging such immutable events is faster and inherently safer compared to <a class="el" href="#srs-qp_emm-mut">mutable events</a> described below. QP Applications should take advantage of immutable events whenever possible.</dd></dl>
<h2><a class="anchor" id="srs-qp_emm-mut"></a>
Mutable Events</h2>
<p>Many event instances, especially <a class="el" href="srs-qp_evt.html#srs-qp_evt-par">events with parameters</a> cannot be easily made immutable because their main function is specifically to deliver information produced at <em>runtime</em>. Consequently, such <b>mutable events</b> must be dynamically created, filled with information (mutated), passed around, and eventually recycled. The management of these processes at runtime is one of the most valuable services QP Framework can provide to QP Application.</p>
<p>The main challenge of managing mutable events is to guarantee that once a mutable event gets posted or published (which might involve event multicasting), it does <em>not change</em> and does not get recycled until all Active Objects have finished their <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">Run-to-Completion</a> processing of that event. In fact, changing or premature recycling the <a class="el" href="srs-qp_ao.html#srs-qp_ao-curr">current event</a> constitutes a violation of the RTC semantics.</p>
<h2><a class="anchor" id="srs-qp_emm-gc"></a>
Automatic Event Recycling</h2>
<p>Every dynamically created mutable event must be eventually recycled, or the memory would leak. Some event-driven systems leave the event recycling to the application, but in the safety-related context, this is considered unreliable and unsafe. Therefore, the event memory management in QP Framework must also include <b>automatic event recycling</b>.</p>
<h2><a class="anchor" id="srs-qp_emm-zero"></a>
Zero-Copy Event Management</h2>
<p>From the safety point of view, the ideal would be to <em>copy</em> entire mutable events into and out of the event queues, as it is often done with the message queues of a traditional RTOS. Unfortunately, it is prohibitively expensive in RAM and nondeterministic in CPU cycles for larger event instances (events with large parameters). However, an event-driven framework, like QP, can be far more sophisticated than a traditional RTOS because, due to <a class="el" href="srs-qp_ao.html#srs-qp_ao-inv">inversion of control</a>, the framework manages an event's <em>whole life cycle</em>. The framework extracts an event from the Active Object's event queue and dispatches it for processing. After the <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">Run-to-Completion processing</a>, the framework <em>regains control</em> of the event and can <a class="el" href="#srs-qp_emm-gc">automatically recycle the event</a>.</p>
<p>An event-driven framework can also easily control the dynamic allocation of mutable events (e.g., the QP Framework provides API for this purpose). All this permits the framework to implement controlled, concurrency-safe sharing of mutable events, which, from the application standpoint, is almost indistinguishable from copying entire events. Such event management is called <b>zero-copy event management</b>.</p>
<p>The whole event memory management must also carefully avoid <em>concurrency hazards</em> around the shared mutable events. Failure in any of those aspects results in defects (bugs) that are the hardest to detect, isolate, and fix.</p>
<h2><a class="anchor" id="srs-qp_emm-ownership"></a>
Mutable Event Ownership Rules</h2>
<p>The zero-copy event management is designed to be intuitive and transparent to the application-level code. However, for the <em>zero-copy event management</em> abstraction to behave exactly like true event copying, QP Application needs to obey specific <b>event ownership rules</b> similar to the rules of working with objects allocated with the C++ operator <code>new</code> and summarized in the life cycle diagram of a mutable event (see <a class="el" href="#srs-qp_fig-evt-life">Figure SRS-EVT-LIFE</a>). In exchange, QP Framework can safely and deterministically deliver your mutable events with hard real-time performance, which does not complicate the RMS/RMA method and is superior to the copying entire events approach.</p>
<p><a class="anchor" id="srs-qp_fig-evt-life"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_evt-life.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-EVT-LIFE: Mutable Event Life Cycle and Ownership Rules</em></center></div><p><a class="el" href="#srs-qp_fig-evt-life">Figure SRS-EVT-LIFE</a> illustrates the mutable event life cycle and possible transfers of ownership rights to the event:</p>
<p><code>[0]</code> All mutable events are initially owned by QP Framework.</p>
<p><code>[1]</code> An event producer might gain ownership of a new event only by allocating it. At this point, the producer gains the ownership rights with the permissions to <b>write</b> to the event. Indeed, the purpose of this stage in the mutable event's life cycle is to initialize the event and fill it with data. The event producer might keep the event as long as it needs. For example, the producer (e.g., ISR) might fill the event with data over many invocations. Eventually, however, the producer must transfer the ownership back to the framework.</p>
<p><code>[2a,2b,2c]</code> Typically the producer posts <code>[2a]</code> or publishes <code>[2b]</code> the event. As a special case, the producer might decide that the event is not good, in which case the producer must <em>explicitly</em> recycle <code>[2c]</code> the event. After any of these three operations, the producer immediately loses ownership of the event and can no longer access it. In particular, it is illegal to post, publish, or recycle the event again.</p>
<p><code>[3]</code> The recipient Active Object gains ownership of the <a class="el" href="srs-qp_ao.html#srs-qp_ao-curr">current event</a> upon the start of the RTC step. This time, the Active Object gains the <b>read-only</b> permissions to the <em>current event</em>.</p>
<p><code>[4a,4b]</code> During the RTC step, the recipient Active Object is allowed to re-post <code>[4a]</code> or re-publish <code>[4b]</code> the <em>current event</em> any number of times without losing ownership of the event.</p>
<p><code>[5a]</code> As a special case, the recipient Active Object may defer the current event. Event deferral extends the read-only ownership rights beyond the current RTC step.</p>
<p><code>[5b]</code> Eventually, however, the deferred event must be recalled, which self-posts the event into the Active Object's event queue (using the LIFO policy). Recalling ends the ownership of the original deferred event.</p>
<p><code>[6]</code> The end of the RTC step terminates the ownership of the <em>current event</em>. The Active Object cannot use the event in any way past the RTC step. In particular, if any data from that event is needed in the future, QP Application must save that data (typically in some attributes inside the Active Object).</p>
<h2><a class="anchor" id="srs-qp_emm-pools"></a>
Event Pools</h2>
<p>To manage the memory for mutable events, QP Framework needs deterministic, efficient, and concurrency-safe method of dynamically allocating and recycling the event memory. The general-purpose, variable-block-size heap does not fit this bill and is inappropriate for safety-related applications, anyway. However, simpler, higher-performance, and <em>safer</em> options exist to the general-purpose heap. A well-known alternative, commonly supported by RTOSs, is a fixed-block-size heap, also known as a memory partition or <em>memory pool</em>. Memory pools are a much better choice for a real-time framework like QP to manage mutable event memory than the general-purpose heap. Unlike the conventional (variable-block-size) heap, a memory pool is deterministic, has guaranteed capacity, and is not subject to fragmentation because all blocks are exactly the same size.</p>
<p>The most obvious drawback of a memory pool is that it does not support variable-sized blocks. Consequently, the blocks have to be oversized to handle the biggest possible allocation. Such a policy is often too wasteful if the actual sizes of allocated objects (mutable events, in this case) vary a lot. A good compromise is often to use not one but <em>multiple</em> memory pools with memory blocks of different sizes. QP Framework chooses that option to implement <b>event pools</b>, which are multiple memory pools specialized to hold mutable events.</p>
<h1><a class="anchor" id="srs-qp_emm-req"></a>
Requirements</h1>
<p><a id="a55_SRS_5FQP_5FEMM_5F00" name="a55_SRS_5FQP_5FEMM_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_00"></a>
SRS_QP_EMM_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_00</b>: <em>QP Framework shall support immutable events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for immutable events means that QP Framework shall provide a way to create and initialize them (including allocation and initialization in ROM). Also, QP Framework must recognize and distinguish immutable events from mutable events and should never attempt to manage immutable events as mutable. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Framework can fulfill this requirement by embedding a unique immutable-event signature in the internal data of the event (see <a class="el" href="srs-qp_evt.html#SRS_QP_EVT_31">SRS_QP_EVT_31</a>). QP Framework must then provide a constant initializer for immutable events. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em><ul>
<li>SAS_QP_FUSA_02: <em><u>Error detecting codes</u> mechanisms to protect critical variables.</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QA_START">SDS_QA_START</a>: <em>QA Application startup sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_POST">SDS_QP_POST</a>: <em>QP event posting sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_PUB">SDS_QP_PUB</a>: <em>QP event publishing sequence</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a56_SRS_5FQP_5FEMM_5F10" name="a56_SRS_5FQP_5FEMM_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_10"></a>
SRS_QP_EMM_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_10</b>: <em>QP Framework shall support mutable events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for mutable events means that QP Framework shall provide a way to create and initialize them. Also, QP Framework must recognize and distinguish mutable events from immutable events and should never attempt to manage mutable events as immutable. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="sas-qp_res.html#SAS_QP_EMM">SAS_QP_EMM</a>: <em>Event memory management policy</em><ul>
<li>SAS_QP_FUSA_02: <em><u>Error detecting codes</u> mechanisms to protect critical variables.</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QA_START">SDS_QA_START</a>: <em>QA Application startup sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_POST">SDS_QP_POST</a>: <em>QP event posting sequence</em></li>
<li><a class="el" href="sds-qp_inter.html#SDS_QP_PUB">SDS_QP_PUB</a>: <em>QP event publishing sequence</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a57_SRS_5FQP_5FEMM_5F11" name="a57_SRS_5FQP_5FEMM_5F11"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_11"></a>
SRS_QP_EMM_11</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_11</b>: <em>QP Framework shall support up to 15 event pools for mutable events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Support for mutable events means that QP Framework shall support multiple, deterministic <a class="el" href="#srs-qp_emm-pools">event pools</a> with different block sizes. The maximum number of event pools managed by QP Framework at any given time shall be compile-time configurable with the maximum of 15 event pools. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Application configures QP for the maximum number of event pools to 5 but initializes only 3 event pools, each for a different event size. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a58_SRS_5FQP_5FEMM_5F20" name="a58_SRS_5FQP_5FEMM_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_20"></a>
SRS_QP_EMM_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_20</b>: <em>QP Framework shall provide a method of allocating mutable events at runtime.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The allocation shall choose the appropriate event pool from which to allocate the event based on the event size. The method of allocating mutable events shall be available to all event producers, such as Active Objects, but also ISRs, "device drivers", or "naked" thread of an RTOS (if a traditional RTOS is used). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Framework might meet this requirement by sorting the event pools internally based on their increasing block size. Then any given event is allocated from the smallest block-size event pool that fits the requested event size. </p>
</td></tr>
</table>
<p><a id="a59_SRS_5FQP_5FEMM_5F30" name="a59_SRS_5FQP_5FEMM_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_30"></a>
SRS_QP_EMM_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_30</b>: <em>QP Framework shall support automatic recycling of mutable events according to the "zero-copy" memory management policy.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework shall keep track of every use of a mutable event, so that it can support the event life-cycle and ownership rules spelled out in <a class="el" href="#srs-qp_fig-evt-life">Figure SRS-EVT-LIFE</a>. In particular, QP Framewrok shall automatically recycle an unused event. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">One way to meet this requirement is for QP Framewrok to use the standard reference-counting algorithm for mutable events. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a60_SRS_5FQP_5FEMM_5F40" name="a60_SRS_5FQP_5FEMM_5F40"></a> </p>
<h2><a class="anchor" id="SRS_QP_EMM_40"></a>
SRS_QP_EMM_40</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_EMM_40</b>: <em>QP Framework shall provide a method of explicitly recycling mutable events.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The method of recycling mutable events back to the appropriate event pool shall be available to all event producers, such as Active Objects, but also ISRs, "device drivers", or "naked" thread of an RTOS (if a traditional RTOS is used). </p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_edm.html">Event Delivery Mechanisms</a></span><span class="next_button"><a class="el" href="srs-qp_tm.html">Time Management</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

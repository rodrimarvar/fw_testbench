<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Active Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_ao.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Active Objects</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_over.html">Overview</a></span><span class="next_button"><a class="el" href="srs-qp_evt.html">Events</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_ao-intro"></a>
Concepts &amp; Definitions</h1>
<p>As described in the <a class="el" href="srs-qp_over.html">Overview</a>, the main goal of the QP Framework is to provide a lightweight and efficient implementation of the <b>Active Object Model of Computation</b> with the specific focus on real-time embedded (RTE) systems, such as single-chip microcontroller units (MCUs).</p>
<h2><a class="anchor" id="srs-qp_ao-model"></a>
Active Object Model of Computation</h2>
<p>The Active Object Model of Computation represents a paradigm shift compared to the traditional "shared state concurrency" based on explicit mutual exclusion and managing threads by blocking. The following subsections describe Active Object properties and explain why this model of computation is <b>safer</b> and makes it easier to write <b>correct concurrent software</b>.</p>
<h2><a class="anchor" id="srs-qp_ao-def"></a>
Active Objects</h2>
<p><b>Active Objects</b> (a.k.a., Actors) are autonomous software objects, each possessing an <a class="el" href="#srs-qp_ao-queue">event queue</a> and <a class="el" href="#srs-qp_ao-exec">execution context</a>. They encapsulate state and behavior and communicate <a class="el" href="#srs-qp_ao-asynch">asynchronously</a> by exchanging events. <a class="el" href="#srs-qp_fig-aos">Figure SRS-AOS</a> below shows a QP Application consisting of multiple, event-driven Active Objects that collectively deliver the desired functionality:</p>
<p><a class="anchor" id="srs-qp_fig-aos"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_aos.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-AOS: Active Objects in QP</em></center></div><h2><a class="anchor" id="srs-qp_ao-enc"></a>
Encapsulation for Concurrency</h2>
<p>The traditional object-oriented encapsulation, as provided by C++, C# or Java, does not really encapsulate anything in terms of <b>concurrency</b>. As shown in <a class="el" href="#srs-qp_fig-seq-th">Figure SRS-SEQ-TH</a>, any operation on a <em>passive</em> object still runs in the caller's thread. If that passive object is shared among multiple threads, the object's attributes are subject to the same race conditions as global data, not encapsulated at all. To become concurrency-safe, operations need to be explicitly protected by an appropriate mutual exclusion mechanism, such as a mutex (for threads) or a critical section (for Interrupt Service Routines). However, this reduces responsiveness (blocking or increased latency), causes contention, and often leads to missed real-time deadlines <a class="el" href="srs-qp.html#srs-qp_ref">[Sutter:10]</a>. Also this style of managing concurrency is <b>inherently unsafe</b> because developers might simply forget to apply mutual exclusion or use an incorrect mechanism, which can lead to latent, highly intermittent, hard-to-find and hard-to-fix concurrency bugs.</p>
<p><a class="anchor" id="srs-qp_fig-seq-th"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_seq-th.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-SEQ-TH: Threads interacting (synchronously) with a passive object</em></center></div><p>In contrast, as shown in <a class="el" href="#srs-qp_fig-aos">Figure SRS-AOS</a>, all interactions with an <em>Active</em> Object occur by posting events, which are all handled in the execution context of the Active Object. As long as there is <a class="el" href="#srs-qp_ao-sharing">no sharing</a> of data or resources among Active Objects (or any other concurrent entities), there are <b>no concurrency hazards</b>. Also, because each event is processed to completion (see <a class="el" href="#srs-qp_ao-rtc">Run-to-Completion processing</a>), event processing is naturally serialized. This means that an Active Object is truly encapsulated without any mutual exclusion mechanisms. In this sense Active Objects are the most stringent form of object-oriented programming because they enable strict <b>encapsulation for concurrency</b>, which is much <b>safer</b> than the "naked" threads.</p>
<p><a class="anchor" id="srs-qp_fig-seq-ao"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_seq-ao.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-SEQ-AO: Threads interacting (asynchronously) with an Active Object</em></center></div><h2><a class="anchor" id="srs-qp_ao-sharing"></a>
Shared-Nothing Principle</h2>
<p>Encapsulation for concurrency is not a programming language feature, so it is no more difficult to achieve in C as in C++, but it requires a <em>programming discipline</em> on behalf of the application developers to <b>avoid sharing</b> resources ("shared-nothing" principle). However, the event-based communication helps immensely, because instead of sharing a resource, a dedicated Active Object can become the manager/broker of the resource and the rest of the system can access the resource only via <em>events</em> posted to this broker Active Object.</p>
<dl class="section attention"><dt>Attention</dt><dd>QP Framework by itself cannot and is not required to guarantee or enforce the <em>shared-noting</em> principle. Achieving the strict no-sharing of resources among Active Objects is the responsibility of the QP Applications. But at the very least, the QP Framework architecture and design must provide adequate and thread-safe <em>event-based</em> information exchange mechanisms, which can replace the traditional sharing of data or resources.</dd></dl>
<h2><a class="anchor" id="srs-qp_ao-exec"></a>
Execution Context</h2>
<p>In the UML, Active Object is defined as: <em>"the object having its own thread of control"</em> <a class="el" href="srs-qp.html#srs-qp_ref">[UML 2.5]</a>. A traditional thread might indeed be used for Active Objects when the QP Framework runs on top of a traditional multitasking kernel (e.g., traditional RTOS or general-purpose OS).</p>
<p>However, the Active Object model of computation can also work with real-time kernels that don't necessarily support the notion of traditional <em>blocking</em> threads. Active Objects have <a class="el" href="#srs-qp_ao-block">no need for blocking</a> while handling events, which opens up possibilities of using lightweight, <em>non-blocking</em> kernels that might be non-preemptive or fully preemptive. (See also lightweight kernels provided in QP, such as <a class="el" href="srs-qp_qv.html">Non-Preemptive Kernel</a>, <a class="el" href="srs-qp_qk.html">Preemptive Non-Blocking Kernel</a>, and <a class="el" href="srs-qp_qxk.html">Preemptive Dual-Mode Kernel</a>.)</p>
<h2><a class="anchor" id="srs-qp_ao-prio"></a>
Priority</h2>
<p>The execution context of an Active Object is closely related to its <b>priority</b> relative to other Active Objects or "naked" threads in the system. In fact, an Active Object can be viewed primarily as a <em>priority level</em> for executing the functionality it encapsulates. In the QP Framework, each Active Object is required to have a <b>unique</b> priority. (See also <a class="el" href="#SRS_QP_AO_01">SRS_QP_AO_01</a>.)</p>
<h2><a class="anchor" id="srs-qp_ao-queue"></a>
Event Queue</h2>
<p>Each Active Object has its own event queue and receives all events exclusively through that queue. This means that the event queue has only a single consumer (the Active Object that owns the queue). On the other hand, the event queue must accommodate multiple producers that don't need to be only Active Objects, but also interrupts (ISRs), or other software components (see <a class="el" href="#srs-qp_fig-aos">Figure SRS-AOS</a>). The Active Object infrastructure, such as the QP Framework in this case, is responsible for delivering and queuing the events in a <em>deterministic</em> and <em>thread-safe</em> manner.</p>
<h2><a class="anchor" id="srs-qp_ao-asynch"></a>
Asynchronous Communication</h2>
<p>All events are delivered to Active Objects <b>asynchronously</b>, meaning that an event producer merely posts an event to the event queue of the recipient Active Object but doesn't wait in line for the actual processing of the event.</p>
<p>The QP Framework makes no distinction between external events generated from interrupts and internal events originating from Active Objects. As shown in <a class="el" href="#srs-qp_fig-aos">Figure SRS-AOS</a>, an Active Object can post events to any other Active Object, including to self. All events are treated uniformly, regardless of their origin.</p>
<h2><a class="anchor" id="srs-qp_ao-rtc"></a>
Run-to-Completion (RTC)</h2>
<p>Each Active Object processes events in <b>run-to-completion (RTC) fashion</b>, which must be guaranteed by the underlying QP Framework. RTC means that Active Objects process the events one at a time and the next event can only be processed after the previous event has been processed completely. RTC event processing is the essential requirement for proper execution of <a class="el" href="#srs-qp_ao-sm">state machines</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is very important to clearly distinguish the notion of RTC from the concept of preemption <a class="el" href="srs-qp.html#srs-qp_ref">[OMG 07]</a>. In particular, <a class="el" href="#srs-qp_ao-rtc">RTC</a> does <em>not</em> mean that the Active Object thread has to monopolize the CPU until the RTC step is complete. In fact, RTC steps <em>can</em> be preempted by interrupts or other threads executing on the same CPU. Such thread preemption is determined by the scheduling policy of the underlying multitasking kernel, not by the Active Object model. When the preempted Active Object is assigned the CPU time again, it resumes its event processing from the point of preemption and, eventually, completes its RTC step. As long as the preempting and the preempted threads don't share any resources (see <a class="el" href="#srs-qp_ao-enc">Encapsulation</a>), there are no concurrency hazards.</dd></dl>
<h2><a class="anchor" id="srs-qp_ao-curr"></a>
Current Event</h2>
<p><b>Current event</b> is the event being processed in the run-to-completion (RTC) step. The event-driven infrastructure (QP Framework in this case) must guarantee that the <em>current event</em> remains available and unchanging for the whole duration of the RTC step.</p>
<h2><a class="anchor" id="srs-qp_ao-block"></a>
No Blocking</h2>
<p>Most traditional operating systems manage the threads and all inter-thread communication based on <em>blocking</em>, such as waiting on a semaphore or a time-delay. However, blocking (as in the middle of the RTC step) is <em>incompatible</em> with the <a class="el" href="#srs-qp_ao-rtc">RTC event processing requirement</a>. This is because every blocking call is really another way to deliver an <em>event</em> (event is delivered by unblocking and return from a blocking call). Such "backdoor" event delivery happening in the middle of the RTC step violates the RTC semantics, because after unblocking the Active Object needs to process two events at a time (the original one and the new one delivered by unblocking).</p>
<p>Another detrimental consequence of blocking (or polling for events) inside RTC steps is that Active Objects become <em>unresponsive</em> to events delivered to their event queues. This, in turn, can cause Active Objects to miss their hard-real time deadlines and also can cause overflow of the internal event queue.</p>
<p>Finally, blocking (or polling for events) means that the expected sequences of events are <em>hard-coded</em>, which is inherently inflexible and not extensible, especially if the system must handle multiple event sequences (which turns out to be the case in most real-life systems).</p>
<h2><a class="anchor" id="srs-qp_ao-sm"></a>
Support For State Machines</h2>
<p>Event-driven components, like Active Objects, must often retain the execution context from one event to the next. This must be done <a class="el" href="#srs-qp_ao-block">without blocking</a>, so the context can't be preserved on the call-stack as it is done in the traditional, blocking RTOS threads. Instead, the context between events must be preserved in some other way, which often leads to multitude of variables and flags checked and modified in a convoluted if-then-else logic (a.k.a. "spaghetti code").</p>
<p>A well know alternative to such "improvised context management" is the concept of a <a class="el" href="srs-qp_sm.html">state machine</a>, which manages the execution context using "states". QP Framework augments and complements the Active Object model of computation by providing support for <a class="el" href="srs-qp_sm.html">state machines</a> to represent the internal behavior of Active Objects.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The relationship between Active Objects and state machines is mutually synergistic. On one hand, the Active Objects provide the execution context and event queuing that the state machines need to process the events in a <a class="el" href="#srs-qp_ao-rtc">run-to-completion</a> fashion. On the other hand, state machines provide the structure and clear design for the event-driven behavior running inside the Active Objects. State machines are also the most constructive part of the design amenable to modeling and automatic code generation.</dd></dl>
<h2><a class="anchor" id="srs-qp_ao-inv"></a>
Inversion of Control</h2>
<p>Event-driven systems require a distinctly different way of thinking than traditional sequential threads. When a sequential thread needs some incoming event, it explicitly <em>blocks</em> and waits in-line until the event arrives. Thus the sequential thread remains "in control" at all times, but while waiting for one kind of event, it cannot respond (at least for the time being) to any other events.</p>
<p>In contrast, most event-driven applications are structured according to the Hollywood principle, which essentially means "Don't call us, we'll call you." So, an event-driven Active Object is not in control while waiting for an event; in fact, it's not even active. Only once the event arrives, the event-driven program is called to process the event and then it quickly relinquishes the control again. This arrangement allows an event-driven program to wait for many events in parallel, so the system remains <em>responsive</em> to all events it needs to handle. This scheme implies that in an event-driven system the control resides within the event-driven infrastructure (QP Framework), rather than in the application. In other words, the control is <em>inverted</em> compared to a traditional sequential thread.</p>
<h2><a class="anchor" id="srs-qp_ao-frame"></a>
Framework vs. Toolkit</h2>
<p>Inversion of control is the key property that makes a software framework different from a software toolkit. A toolkit, such as a traditional RTOS, is essentially a set of predefined functions that you can call. When you use a toolkit, you write the main body of the application, such as the body of all RTOS threads, and call the various blocking functions from the RTOS. When you use a framework (such as QP), you reuse the main body (codified inside the framework) and provide the application code that <em>it</em> calls, so the control resides in the framework rather than in your code. Indeed, this <b>inversion of control</b> gives the event-driven infrastructure all the defining characteristics of a framework:</p>
<p><em>"One important characteristic of a framework is that the methods defined by the user to tailor the framework will often be called from within the framework itself, rather than from the user's application code. The framework often plays the role of the main program in coordinating and sequencing application activity. This &lt;u&gt;inversion of control&lt;/u&gt; gives frameworks the power to serve as extensible skeletons. The methods supplied by the user tailor the generic algorithms defined in the framework for a particular application."</em> <br  />
 &ndash;Ralph Johnson and Brian Foote</p>
<h2><a class="anchor" id="srs-qp_ao-power"></a>
Low Power Architecture</h2>
<p>Most modern embedded microcontrollers (MCUs) provide an assortment of low-power sleep modes designed to conserve power by gating the clock to the CPU and various peripherals. However, the sleep modes are entered under the software control and therefore require an appropriate software infrastructure.</p>
<p>An event-driven framework, like QP, based on inversion of control is particularly suitable for taking advantage of these power-savings features because the framework can easily detect situations in which the system has no more events to process, called the <em>idle condition</em>. In that case the framework can place the MCU into a low-power sleep mode <b>safely</b> and without creating race conditions with active interrupts.</p>
<h1><a class="anchor" id="srs-qp_ao-req"></a>
Requirements</h1>
<p><a id="a0_SRS_5FQP_5FAO_5F00" name="a0_SRS_5FQP_5FAO_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_00"></a>
SRS_QP_AO_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_00</b>: <em>QP Framework shall provide the Active Object abstraction to QP Application</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The Active Object abstraction provided by QP Framework shall be customizable by QP Application and executed by QP Framework according to the Active Object model of computation. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Framework can meet this requirement by proving the Active Object abstraction as a <em>class</em>, which the QP Applications can customize by subclassing. Such an Active Object base class must be customizable at compile-time for a wide variety of real-time kernels, including traditional blocking RTOS and event-driven, non-blocking kernels. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_01">SRS_QP_AO_01</a>: <em>QP Framework shall be able to manage a compile-time configurable number of Active Objects not exceeding 64 instances</em></li>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_CLS">SAS_QP_CLS</a>: <em>QP Framework base classes</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a1_SRS_5FQP_5FAO_5F01" name="a1_SRS_5FQP_5FAO_5F01"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_01"></a>
SRS_QP_AO_01</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_01</b>: <em>QP Framework shall be able to manage a compile-time configurable number of Active Objects not exceeding 64 instances</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The maximum number of Active Object instances managed by QP Framework at any given time shall be compile-time configurable with the maximum of 64 instances. The actual number of Active Object instances registered with QP Framework can be lower than the configured compile-time limit, but it cannot exceed the limit. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_00">SRS_QP_AO_00</a>: <em>QP Framework shall provide the Active Object abstraction to QP Application</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">For best memory and CPU performance, the maximum number of Active Object instances can be configured below the 64 maximum, and often it might be advantageous to use powers of 2, for example, configure the limit as 16 or 32 AO instances. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a2_SRS_5FQP_5FAO_5F10" name="a2_SRS_5FQP_5FAO_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_10"></a>
SRS_QP_AO_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_10</b>: <em>Active Object abstraction shall provide the <u>unique priority</u> for each Active Object instance</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The Active Object <b>priority</b> is a positive integer number between 1 and the maximum configured number of Active Objects (see <a class="el" href="#SRS_QP_AO_20">SRS_QP_AO_20</a>). The priority shall conform to the numbering scheme defined as follows: priority 1 corresponds to the lowest priority and higher numbers correspond to higher priorities (direct priority numbering scheme). The priority 0 cannot be assigned to any Active Object, and is reserved for the idle thread (or the idle condition) of the underlying real-time kernel. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The QP priority numbering scheme is fixed and does not change, even if the underlying real-time kernel uses a different priority scheme (e.g., reversed priority numbering). However, the QP priority must remain consistent with the priority of the underlying kernel in that higher QP priority numbers must correspond to a higher (or at least not lower) <em>urgency</em> threads. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a3_SRS_5FQP_5FAO_5F11" name="a3_SRS_5FQP_5FAO_5F11"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_11"></a>
SRS_QP_AO_11</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_11</b>: <em>Active Object abstraction may provide second "auxiliary priority" for each Active Object instance</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The second "auxiliary priority" may be used for different purposes, depending on the underlying real-time kernel. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Cases</b><br  />
</p>
<p class="endtd">In some real-time kernels, the "auxiliary priority" might be used to represent preemption threshold. In other kernels, it might represent the native thread priority according to the priority numbering scheme of the kernel. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a4_SRS_5FQP_5FAO_5F20" name="a4_SRS_5FQP_5FAO_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_20"></a>
SRS_QP_AO_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_20</b>: <em>Active Object abstraction shall provide an <u>event queue</u> for each Active Object instance</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The event queue type shall be compile-time configurable to allow various blocking/no-blocking mechanisms corresponding to the chosen real-time kernel. The capacity of the event queue (maximum number of events it can hold) shall be run-time configurable before the Active Object instance starts executing. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">QP Framework can meet this requirement by proving event queue as an attribute inside the Active Object class. The type of the event queue must be compile-time configurable to match the underlying real-time kernel that executes the Active Objects in QP. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_21">SRS_QP_AO_21</a>: <em>Active Object event queue shall provide <u>FIFO policy</u> for posting events from outside the Active Object</em><ul>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_00">SRS_QP_EDM_00</a>: <em>QP Framework shall provide direct event posting to Active Object instances based on the FIFO policy</em></li>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_01">SRS_QP_EDM_01</a>: <em>QP Framework shall provide direct event <u>self</u>-posting to Active Object instances based on the LIFO policy</em></li>
</ul>
</li>
<li><a class="el" href="#SRS_QP_AO_22">SRS_QP_AO_22</a>: <em>Active Object event queue shall additionally provide <u>LIFO policy</u> for self-posting events from within the Active Object</em></li>
<li><a class="el" href="#SRS_QP_AO_23">SRS_QP_AO_23</a>: <em>The <u>maximum capacity</u> of the Active Object event queue shall be run-time configurable</em></li>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_00">SRS_QP_EDM_00</a>: <em>QP Framework shall provide direct event posting to Active Object instances based on the FIFO policy</em><ul>
<li>SSR_QP_EDG_10: <em>QP/C Framework shall provide <u>event delivery guarantee</u> for the direct event posting mechanism.</em></li>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em></li>
</ul>
</li>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_01">SRS_QP_EDM_01</a>: <em>QP Framework shall provide direct event <u>self</u>-posting to Active Object instances based on the LIFO policy</em><ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a5_SRS_5FQP_5FAO_5F21" name="a5_SRS_5FQP_5FAO_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_21"></a>
SRS_QP_AO_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_21</b>: <em>Active Object event queue shall provide <u>FIFO policy</u> for posting events from outside the Active Object</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">FIFO stands for First-In-First-Out and means that the events are extracted from the queue in the <em>same</em> order in which they have been inserted into the queue. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_20">SRS_QP_AO_20</a>: <em>Active Object abstraction shall provide an <u>event queue</u> for each Active Object instance</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_00">SRS_QP_EDM_00</a>: <em>QP Framework shall provide direct event posting to Active Object instances based on the FIFO policy</em><ul>
<li>SSR_QP_EDG_10: <em>QP/C Framework shall provide <u>event delivery guarantee</u> for the direct event posting mechanism.</em></li>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em></li>
</ul>
</li>
<li><a class="el" href="srs-qp_edm.html#SRS_QP_EDM_01">SRS_QP_EDM_01</a>: <em>QP Framework shall provide direct event <u>self</u>-posting to Active Object instances based on the LIFO policy</em><ul>
<li><a class="el" href="sas-qp_ctxt.html#SAS_QP_API">SAS_QP_API</a>: <em>QP Framework API</em> </li>
</ul>
</li>
</ul>
</td></tr>
</table>
<p><a id="a6_SRS_5FQP_5FAO_5F22" name="a6_SRS_5FQP_5FAO_5F22"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_22"></a>
SRS_QP_AO_22</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_22</b>: <em>Active Object event queue shall additionally provide <u>LIFO policy</u> for self-posting events from within the Active Object</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">LIFO stands for Last-In-First-Out and means that the events are extracted from the queue in the <em>reversed</em> order in which they have been inserted into the queue. The support for the LIFO policy for self-posting should be in <em>addition</em> to supporting the standard FIFO policy. In other words, QP Application can choose to self-post any given event either with the FIFO or LIFO policy. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_20">SRS_QP_AO_20</a>: <em>Active Object abstraction shall provide an <u>event queue</u> for each Active Object instance</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a7_SRS_5FQP_5FAO_5F23" name="a7_SRS_5FQP_5FAO_5F23"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_23"></a>
SRS_QP_AO_23</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_23</b>: <em>The <u>maximum capacity</u> of the Active Object event queue shall be run-time configurable</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The maximum capacity of an event queue is the maximum number of events that can be inside the queue at any given time. This maximum capacity shall be determined at run-time. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The event queue can be supplied with the buffer memory to hold the events at run-time. The size of that memory buffer will determine the maximum capacity of the event queue. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_20">SRS_QP_AO_20</a>: <em>Active Object abstraction shall provide an <u>event queue</u> for each Active Object instance</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a8_SRS_5FQP_5FAO_5F30" name="a8_SRS_5FQP_5FAO_5F30"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_30"></a>
SRS_QP_AO_30</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_30</b>: <em>Active Object abstraction may provide an optional <u>execution context</u> for each Active Object instance</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The execution context (e.g., thread) attribute shall be compile-time configurable to allow various thread types corresponding to the chosen real-time kernel. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">In case QP uses a traditional RTOS, the execution context might be a thread-control-block (TCB) or just a thread handle/pointer. In case of other real-time kernels, the execution context might be a thread identifier or might not be needed at all. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a9_SRS_5FQP_5FAO_5F31" name="a9_SRS_5FQP_5FAO_5F31"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_31"></a>
SRS_QP_AO_31</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_31</b>: <em>QP Framework shall allow Active Object instances to be started at runtime</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Starting an Active Object instance means registering it with the QP Framework, so that the framework can start managing the Active Object. Only after an Active Object instance has been started, it can receive and process events. Starting at runtime means that Active Object instances can start at any time during the normal system operation (as opposed to starting only during system initialization). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">Starting an Active Object instance might involve initializing its event queue and creating and/or starting the execution context. Only after that, the underlying real-time kernel can include the Active Object in the scheduling process. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a10_SRS_5FQP_5FAO_5F32" name="a10_SRS_5FQP_5FAO_5F32"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_32"></a>
SRS_QP_AO_32</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_32</b>: <em>QP Framework may allow Active Object instances to be stopped at runtime</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Stopping an Active Object instance means stopping its execution context and unregistering it from QP Framework. Stopping an Active Object does not mean that it is deleted, destroyed, or its memory is recycled. Stopping only means that the Active Object is no longer managed by QP Framework and stops participating in scheduling and event processing. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Background</b><br  />
</p>
<p class="endtd">The biggest challenge in stopping an Active Object is to perform it <b>cleanly</b>, without disrupting the rest of the application. For example, the stopped Active Object should not receive any events from the rest of the application. Also, the Active Object should not have any events to process in its queue. For these reasons, stopping an Active Object is optional, and is <b>not recommended</b>, especially in safety-related applications. Instead of stopping an Active Object, a better design is to post a special event to that Active Object, which could trigger a transition to a special "stopped" state in the Active Object's state machine. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a11_SRS_5FQP_5FAO_5F40" name="a11_SRS_5FQP_5FAO_5F40"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_40"></a>
SRS_QP_AO_40</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_40</b>: <em>Active Object abstraction may provide optional "operating-system object" for each Active Object instance</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The optional "operating system object" shall be compile-time configurable to allow various operating-system object types corresponding to the selected real-time kernel. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">For example, the Active Object's event-queue for the POSIX operating system might require additional condition-variable attribute ("operating system object") to implement blocking on an empty queue. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a12_SRS_5FQP_5FAO_5F50" name="a12_SRS_5FQP_5FAO_5F50"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_50"></a>
SRS_QP_AO_50</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_50</b>: <em>Active Object abstraction shall <u>encapsulate</u> its internals</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The Active Object abstraction should hide and protect its internals, both for reading and writing by any outside entities. Additionally, QP Framework shall allow the QP Application to hide and protect any additional attributes added to the derived Active Objects. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_51">SRS_QP_AO_51</a>: <em>Active Object abstraction shall allow Applications to easily access the internal attributes from inside the Active Object</em> </li>
</ul>
</td></tr>
</table>
<p><a id="a13_SRS_5FQP_5FAO_5F51" name="a13_SRS_5FQP_5FAO_5F51"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_51"></a>
SRS_QP_AO_51</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_51</b>: <em>Active Object abstraction shall allow Applications to easily access the internal attributes from inside the Active Object</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Notwithstanding Requirement <a class="el" href="#SRS_QP_AO_10">SRS_QP_AO_10</a>, QP Framework shall allow for easy and computationally inexpensive access to the internal attributes of an Active Object from <em>within</em> the AO, such as from its internal state machine. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">A good example of implementing such a policy is the concept of class encapsulation in OOP, where the internal attributes are accessible to the class operations (e.g., via the <code>this</code> pointer) and are harder to access from the outside. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="#SRS_QP_AO_50">SRS_QP_AO_50</a>: <em>Active Object abstraction shall <u>encapsulate</u> its internals</em></li>
<li><a class="el" href="srs-qp_sm.html#SRS_QP_SM_24">SRS_QP_SM_24</a>: <em>All State Machine Implementation Strategies provided by QP shall allow Applications to easily access the <u>instance variables</u> associated with a given state machine object</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a14_SRS_5FQP_5FAO_5F60" name="a14_SRS_5FQP_5FAO_5F60"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_60"></a>
SRS_QP_AO_60</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_60</b>: <em>Active Object abstraction shall support <u>run-to-completion event processing</u></em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework must guarantee that every event is processed to completion, regardless of the real-time kernel used, and that during the RTC step the <a class="el" href="#srs-qp_ao-curr">current event</a> remains available and unchanged. </p>
</td></tr>
</table>
<p><a id="a15_SRS_5FQP_5FAO_5F70" name="a15_SRS_5FQP_5FAO_5F70"></a> </p>
<h2><a class="anchor" id="SRS_QP_AO_70"></a>
SRS_QP_AO_70</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_AO_70</b>: <em>Active Object abstraction shall provide support for <u>state machines</u>.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Each Active Object instance shall have an internal state machine, with the features and semantics specified in Section <a class="el" href="srs-qp_sm.html">State Machines</a>. QP Framework shall guarantee execution of such internal state machines in Run-to-Completion fashion. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Backward Traceability</b><br  />
</p>
<ul>
<li><a class="el" href="srs-qp_sm.html#SRS_QP_SM_00">SRS_QP_SM_00</a>: <em>QP Framework shall provide support for hierarchical state machines both for Active Objects and for passive event-driven objects in the Application</em> </li>
</ul>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_over.html">Overview</a></span><span class="next_button"><a class="el" href="srs-qp_evt.html">Events</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>

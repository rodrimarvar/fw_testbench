<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Non-Preemptive Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="spexy-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.webp"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">8.0.2</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('srs-qp_qv.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Non-Preemptive Kernel</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs-qp_qs.html">Software Tracing</a></span><span class="next_button"><a class="el" href="srs-qp_qk.html">Preemptive Non-Blocking Kernel</a></span> </p><div style="clear:both"></div> <h1><a class="anchor" id="srs-qp_qv-intro"></a>
Concepts &amp; Definitions</h1>
<p>The <a class="el" href="srs-qp_ao.html#srs-qp_ao-model">Active Object model of computation</a> can work with a wide range of real-time kernels. Specifically for the kernel discussed in this section, an Active Object requires an <a class="el" href="srs-qp_ao.html#srs-qp_ao-exec">execution context</a> only during the <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC (Run-to-Completion) processing</a> and an Active Object that is merely <em>waiting</em> for events does not need an execution context at all. This opens up possibility of executing multiple Active Objects in a single thread (e.g., the <code>main()</code> function in C or C++).</p>
<h2><a class="anchor" id="srs-qp_qv-def"></a>
QV Non-Preemptive Kernel</h2>
<p>QV is a simple non-preemptive, cooperative, fixed-priority, event-driven kernel integrated with the QP Framework. As shown in <a class="el" href="#srs-qp_fig-qv-loop">Figure SRS-QV-LOOP</a>, QV executes all Active Objects in the system in a single loop (similar to the traditional "superloop", a.k.a. "main+ISRs" architecture), so Active Objects cannot preempt each other (<b>non-preemptive</b> kernel). The QV priority-based scheduler engages only at the top of the loop and selects the highest-priority Active Object ready to run (with some event(s) in its queue). When such Active Object is found, QV executes the <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC step</a> in this Active Object and then loops back. That way, Active Objects <b>cooperate</b> to share a single "superloop" and implicitly yield to each other after every <a class="el" href="srs-qp_ao.html#srs-qp_ao-rtc">RTC step</a>. When the QV scheduler finds no Active Objects ready to run, it invokes the <a class="el" href="#srs-qp_qv-idle">idle processing</a>.</p>
<p><a class="anchor" id="srs-qp_fig-qv-loop"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qv-loop.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QV-LOOP: QV non-preemptive kernel loop.</em></center></div><dl class="section note"><dt>Note</dt><dd>The QV kernel enables partitioning the application into separate Active Objects, while preserving the simplicity and portability of the "superloop" architecture. Due to the simplicity and restrictions on preemption (which is only allowed for ISRs), the QV kernel is a <em>recommended</em> choice for <b>safety-critical</b> applications.</dd></dl>
<h2><a class="anchor" id="srs-qp_qv-share"></a>
Sharing Resources in QV</h2>
<p>As described in the <a class="el" href="srs-qp_ao.html#srs-qp_ao-sharing">Shared-Nothing Principle</a> for Active Objects, QP Applications should generally strive to avoid any sharing of resources among Active Objects. However, the simplistic and <em>non-preemptive</em> nature of the QV kernel allows applications to relax the "shared-nothing" principle and safely share some resources among Active Objects.</p>
<dl class="section note"><dt>Note</dt><dd>As soon as any resource sharing among Active Objects is introduced, the application becomes locked to a <em>non-preemptive</em> kernel and stops being portable to a <em>preemptive</em> kernel. Conversely, an application that heeds the <a class="el" href="srs-qp_ao.html#srs-qp_ao-sharing">Shared-Nothing Principle</a> remains widely portable to any real-time kernel, including <em>preemptive</em> kernels.</dd></dl>
<h2><a class="anchor" id="srs-qp_qv-idle"></a>
Idle Processing in QV</h2>
<p>The situation when QV scheduler finds no events for processing in a given pass through the "superloop" is called the <b>idle condition</b>. In that case, the QV kernel executes <b>idle processing</b> to let the application, among others, put the CPU and peripherals in a <em>low-power sleep mode</em> (see <a class="el" href="#srs-qp_fig-qv-idl">Figure SRS-QV-IDL</a>). Existence of such a single point to apply low-power modes is a hallmark of a <b>power-friendly architecture</b>.</p>
<p>However, as in the traditional "superloop" (a.k.a., "foreground/background" architecture) QV kernel must detect the <em>idle condition</em> inside a critical section (with interrupts disabled) and must be careful to enter the low-power mode <b>safely</b> without re-enabling interrupts too soon (see <a class="el" href="srs-qp.html#srs-qp_ref">[Samek:07]</a>). Otherwise any interrupt allowed after determining the <em>idle condition</em> but before calling the <em>idle processing</em> could post events to Active Objects, thus invalidating the <em>idle condition</em>. However, due to the simplistic, non-preemptive nature of the QV kernel, the idle processing would still be called and would enter the sleep mode while some events might be available and waiting (indefinitely) for processing.</p>
<p><a class="anchor" id="srs-qp_fig-qv-idl"></a></p><div class="image">
<object type="image/svg+xml" data="srs-qp_qv-idl.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-QV-IDL: QV non-preemptive kernel idle processing</em></center></div><dl class="section note"><dt>Note</dt><dd>The need to enter the <em>low-power sleep mode</em> with interrupts still disabled (or atomically with re-enabling interrupts) is a unique requirement of a <em>non-preemptive</em> kernel, such as QV. This requirement does not apply to <em>preemptive</em> kernels.</dd></dl>
<h2><a class="anchor" id="srs-qp_qv-rt"></a>
Task-Level Response in QV</h2>
<p>The maximum time an event for the highest-priority Active Object can be delayed is called the <b>task-level response</b>. The task-level response in the QV kernel is equal to the longest RTC step of all Active Objects in the system. Note that this task-level response is still a lot better than the traditional "superloop" (a.k.a. main+ISRs) architecture, where the task-level response is typically the <em>sum</em> of the worst-case execution times of all tasks in the "superloop".</p>
<p>Due to the <a class="el" href="srs-qp_ao.html#srs-qp_ao-block">non-blocking</a> nature of event processing inside Active Objects, the RTC steps tend to be short (typically microseconds), which can deliver adequate real-time performance to surprisingly wide range of applications. Also, the task-level response can be often improved by breaking up the longest RTC steps into shorter pieces (multi-stage processing). For example, an Active Object can perform only a fraction of the overall event processing and post event to self to trigger continuation next time ("Reminder" state pattern).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Sometimes the task-level response of the simple QV kernel might be too slow and it is impractical to break up all the long RTC steps into shorter pieces. In such cases a <em>preemptive</em> kernel (such as <a class="el" href="srs-qp_qk.html">QK</a>, <a class="el" href="srs-qp_qxk.html">QXK</a>, or a traditional RTOS) can provide a more robust solution. The big advantage of a preemptive kernel is that it effectively decouples high-priority Active Objects from low-priority Active Objects in the <em>time domain</em>. The timeliness of execution of high-priority Active Object is almost independent on the low-priority Active Objects. However, preemptive kernels open the whole new class of problems, collectively known as <em>concurrency hazards</em>.</dd></dl>
<h1><a class="anchor" id="srs-qp_qv-req"></a>
Requirements</h1>
<p><a id="a80_SRS_5FQP_5FQV_5F00" name="a80_SRS_5FQP_5FQV_5F00"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_00"></a>
SRS_QP_QV_00</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_00</b>: <em>QP Framework shall provide non-preemptive QV kernel as one of the built-in kernels.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework shall provide QV kernel implementation and ports to the supported CPU/compiler combinations as one of the optional software components. QP Application can then choose the QV kernel to execute Active Objects. Such a selection is exclusive, meaning that when QP Application selects the QV kernel, other kernels are excluded and cannot be used. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">QP Framework can implement the QV kernel component by re-using already existing mechanisms, such as event queues for Active Objects, event delivery mechanisms, event memory management, etc. That way, the QV kernel implementation can be quite small and consist only of the missing pieces, such as the "superloop" with the QV scheduler. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a81_SRS_5FQP_5FQV_5F10" name="a81_SRS_5FQP_5FQV_5F10"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_10"></a>
SRS_QP_QV_10</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_10</b>: <em>QV kernel shall provide an idle-callback defined in QP Application.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="intertd">When no events are available in a given pass through the "superloop" (see <a class="el" href="#srs-qp_fig-qv-loop">Figure SRS-QV-SCH</a>), the QV kernel executes <a class="el" href="#srs-qp_qv-idle">idle processing</a>. This idle processing shall invoke an <b>idle-callback</b> (a function) defined in QP Application. The <em>idle-callback</em> can perform any processing, including putting the CPU and peripherals in a low-power sleep mode.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>idle-processing</em> of the QV kernel can be viewed as the lowest-priority task that can't be preempted by other Active Objects. Consequently the idle-processing time also counts as another RTC step, which must be considered for the <a class="el" href="#srs-qp_qv-rt">task-level response</a> of the QV kernel.</dd></dl>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The <em>idle-callback</em> can perform <a class="el" href="srs-qp_qs.html">Software Tracing</a> data transfer to the host, or other processing. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a82_SRS_5FQP_5FQV_5F11" name="a82_SRS_5FQP_5FQV_5F11"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_11"></a>
SRS_QP_QV_11</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_11</b>: <em>The idle-callback shall be invoked with interrupts <u>disabled</u> to allow a <u>safe</u> transition to a low-power sleep mode.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">As described in Section <a class="el" href="#srs-qp_qv-idle">Idle Processing in QV</a>, a <b>safe</b> transition to low-power sleep mode requires the QV <em>idle-callback</em> to be invoked with <b>interrupts disabled</b> (inside the same critical section as the detection of the <em>idle condition</em>). </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a83_SRS_5FQP_5FQV_5F12" name="a83_SRS_5FQP_5FQV_5F12"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_12"></a>
SRS_QP_QV_12</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_12</b>: <em>The idle-callback shall always return with interrupts <u>enabled</u>.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">Regardless whether the <em>idle-callback</em> switches to a low-power mode, QP Application must define the <em>idle-callback</em> such that it re-enables interrupts in every path through the code. The QV kernel assumes that this will be the case, and will not work correctly if the <em>idle-callback</em> fails to enable interrupts. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a84_SRS_5FQP_5FQV_5F20" name="a84_SRS_5FQP_5FQV_5F20"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_20"></a>
SRS_QP_QV_20</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_20</b>: <em>QV kernel may provide API to selectively disable scheduling Active Objects below the specified scheduler-disable ceiling priority.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The selective scheduler disabling API shall prevent scheduling any Active Object whose <a class="el" href="srs-qp_ao.html#srs-qp_ao-prio">unique priority</a> is below the specified <em>scheduler-disable ceiling priority</em>. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The main use case for selective scheduler disabling is in <b>time-triggered</b> designs and Active Objects with multi-stage processing. An Active Object that breaks up its long RTC steps into shorter pieces (multi-stage processing) would self-post a special "Reminder" event to trigger subsequent stages of processing. However, to prevent such processing from overrunning the next clock period, the Active Object can explicitly disable the QV scheduler up to its own priority level. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a id="a85_SRS_5FQP_5FQV_5F21" name="a85_SRS_5FQP_5FQV_5F21"></a> </p>
<h2><a class="anchor" id="SRS_QP_QV_21"></a>
SRS_QP_QV_21</h2>
<table class="doxtable">
<tr>
<td style="text-align:left; width:var(--content-maxwidth)"><p class="starttd"><b>SRS_QP_QV_21</b>: <em>If QV kernel provides API to disable the scheduler it shall provide the API to enable the scheduler.</em></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"><b>Description</b><br  />
</p>
<p class="endtd">The scheduler enabling API shall complement the scheduler disabling API (see <a class="el" href="#SRS_QP_QV_20">SRS_QP_QV_20</a>). The scheduler enabling API shall restore the <em>scheduler-disable ceiling</em> established in the most recent call to the scheduler disabling API. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Use Case</b><br  />
</p>
<p class="endtd">The main use case for scheduler enabling (matching the use case in <a class="el" href="#SRS_QP_QV_20">SRS_QP_QV_20</a>) is enabling the QV scheduler in the system clock tick. </p>
</td></tr>
<tr>
<td><p class="starttd"><b>Forward Traceability (truncated to 2 level(s))</b><br  />
</p>
<p class="endtd"></p>
</td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs-qp_qs.html">Software Tracing</a></span><span class="next_button"><a class="el" href="srs-qp_qk.html">Preemptive Non-Blocking Kernel</a></span>   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs-qp.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2025 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 8.0.2</b> &nbsp;|&nbsp; created with <a title="Spexygen: traceable specifications" href="https://github.com/QuantumLeaps/spexygen"><em>Spexygen</em></a>
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
